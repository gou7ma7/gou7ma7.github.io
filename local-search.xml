<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>install_ollama</title>
    <link href="/2025/02/24/devops/install_ollama/"/>
    <url>/2025/02/24/devops/install_ollama/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AI 时代的第一篇博客</title>
    <link href="/2025/02/24/career/1st_post_in_ai_era/"/>
    <url>/2025/02/24/career/1st_post_in_ai_era/</url>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>很有意思啊，经历了之前的焦虑后，开始恢复状态能正常开始学习了。</p><p>第三次被裁员了，前段时间心态起伏还是很大的，再加上家庭频出状况，很长一段时间不能集中精力学习，不过考虑到当时甚至连游戏都没有兴趣玩，现在也觉得没啥问题，哈哈。</p><p>之前删掉了啰嗦的充满“操作指南”、“操作记录”的博客，想着在 AI 时代没什么用，但是经过最近的学习，反而发现这些才是在 RAG 下宝贵的学习资料。</p><p>因为之前博客写完了，就像中学时代的“笔记”，“错题本”一样被动的放在那里，除非高度规律地规划定期回顾才能被用起来，而现在不同了，我需要迭代自己的 Workflow 了。</p><p><img src="/2025/02/24/career/1st_post_in_ai_era/screen.jpg" alt="做减法，不要再在桌子上摆很多个屏幕了"></p><h1 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h1><p>以前喋喋不休地在博客、抖音、B站、小红书上打卡，抱团，期望能坚持此前一直没能完成的减肥，但效果甚微。</p><p>大道至简，就和学习本身一样，没有每天落地的实践支持，都是空中楼阁，徒增笑耳。</p><!-- <img src="/2025/02/24/career/1st_post_in_ai_era/weight_loss_record.jpeg" class=""> --><p><img src="/2025/02/24/career/1st_post_in_ai_era/weight_loss_record.jpeg" alt="减肥数值记录"></p><h1 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h1><p>过去的一年里我成为了父亲，又失去了父亲，在这个社会角色定位中，我没有退路了。</p><p>小孩刚出生的时候太轻，妈妈操了太多的心。我当时暗下决心，希望我减肥下来的体重都能加到小孩上。</p><p>然后小孩体重稳步提升，达到了正常体重，反而是我却减得快多了，这是最近最值得开心的事情了。</p><p>迷茫的时候也想想，就像踏实减肥一样，积累到了才会看到成效，毕竟：</p><blockquote><p>没有数值，我只看到了努力和汗水。</p></blockquote><h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><p>AI 带来了很多改变啊，在首页里面已经有了足够的碎碎念了。</p><p>这段时间深度体验 + 部署之后，发现现阶段的 AI 在通识方面已经无敌，但在专业领域完全不能令我满意。</p><p>比如让他帮我生成的技能学习树 <a href="https://gou7ma7.github.io/2025/02/05/skill-tree/index/">https://gou7ma7.github.io/2025/02/05/skill-tree/index/</a> 里面的链接，在能联网搜索的情况下，都全是错的（或者过期的），等我到时候点技能点的时候，去具体更正。</p><p>这也是我现在更有动力更新博客的原因，期望能在 RAG 的帮助下打造成我的个人知识库。</p>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 后端工程师 + DevOps 技能树 -&gt; AIOps</title>
    <link href="/2025/02/05/skill-tree/index/"/>
    <url>/2025/02/05/skill-tree/index/</url>
    
    <content type="html"><![CDATA[<p>第三次被裁员后，经历了几十场面试后，需要深入思考自己应该如何立足这个行业。<br>AI 相关的岗位要求越来越多，看下来主要分为部署 AI 产品本身，或者使用 AI 优化传统 DevOps 流程。</p><span id="more"></span><p>刚开始面试的时候，我还在以“过往的业务经历中没有项目实践一笔带过”，并且想着应该夯实基础，而不是追赶潮流。</p><p>直到面某全球一流公司时，前面技术都面秒过，却在领导面的时候，被质疑“不要讲 AI 在你的副业中的落地，我想听到的是你对我们需要的新事物的学习和整合”代表的岗位需要的 AI 相关的能力不足。</p><p>这对我造成了极大冲击，总是想找个不是整天光写业务的公司，但真的问开放问题的时候又没准备好。<br>面试本身是对这个岗位要求的匹配，不只是能力的筛选，平时总是说到要跟上时代不能被淘汰，到了这个时候又搪塞以“工程上没用过”。</p><p>不能这样了，不管是以后的面试，还是平时学习，闭门造车始终是不行的。<br>不得不删除之前写了 4年 的 Blog，重新开始打卡学习，看来也能找回刚学习的时候那种新鲜感了。</p><div id="skillTree" style="width: 100%;height:800px;"></div><div id="zoomControls" style="text-align: center; margin: 10px;">    <button onclick="zoom(1.2)" style="margin: 0 10px;">+</button>    <button onclick="zoom(0.8)" style="margin: 0 10px;">-</button>    <button onclick="resetZoom()" style="margin: 0 10px;">Reset</button></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script><script src="/js/skill-tree-config.js"></script><script src="/js/skill-tree.js"></script><script>    function embedChartAsImage() {        var chart = echarts.getInstanceByDom(document.getElementById('skillTree'));        var imgData = chart.getDataURL({            type: 'png',            pixelRatio: 2,            backgroundColor: '#fff'        });        // Create an image element and set its source to the generated PNG data        var imgElement = document.createElement('img');        imgElement.src = imgData;        imgElement.alt = 'Skill Tree';        // Append the image to the document        document.getElementById('skillTreeContainer').appendChild(imgElement);    }    // Delay the rendering to ensure the chart is fully loaded    window.onload = function() {        setTimeout(embedChartAsImage, 2000); // Delay of 2000 milliseconds (2 seconds)    };</script><div id="skillTreeContainer" style="display: none;"></div><h1 id="详细学习路线"><a href="#详细学习路线" class="headerlink" title="详细学习路线"></a>详细学习路线</h1><h2 id="一、AI-在-DevOps-中的应用（AiOps）"><a href="#一、AI-在-DevOps-中的应用（AiOps）" class="headerlink" title="一、AI 在 DevOps 中的应用（AiOps）"></a>一、AI 在 DevOps 中的应用（AiOps）</h2><h3 id="1-AI-辅助开发"><a href="#1-AI-辅助开发" class="headerlink" title="1. AI 辅助开发"></a>1. AI 辅助开发</h3><ul><li><strong>[ ] AI 代码助手</strong><ul><li><input disabled="" type="checkbox"> GitHub Copilot 使用与优化 [参考：<a href="https://docs.github.com/en/copilot]">https://docs.github.com/en/copilot]</a></li><li><input disabled="" type="checkbox"> 代码生成质量评估 [参考：<a href="https://arxiv.org/abs/2202.13169]">https://arxiv.org/abs/2202.13169]</a></li><li><input disabled="" type="checkbox"> 安全漏洞检测 [参考：<a href="https://github.com/features/security/code-scanning]">https://github.com/features/security/code-scanning]</a></li></ul></li><li><strong>[ ] AI 文档助手</strong><ul><li><input disabled="" type="checkbox"> RAG（Retrieval-Augmented Generation）技术 [参考：<a href="https://arxiv.org/abs/2005.11401]">https://arxiv.org/abs/2005.11401]</a></li><li><input disabled="" type="checkbox"> 知识库构建与维护 [参考：<a href="https://www.pinecone.io/learn/rag/]">https://www.pinecone.io/learn/rag/]</a></li><li><input disabled="" type="checkbox"> 文档自动生成与更新 [参考：<a href="https://github.com/microsoft/DeepSpeed]">https://github.com/microsoft/DeepSpeed]</a></li></ul></li></ul><h3 id="2-AI-增强-CI-CD"><a href="#2-AI-增强-CI-CD" class="headerlink" title="2. AI 增强 CI&#x2F;CD"></a>2. AI 增强 CI&#x2F;CD</h3><ul><li><strong>[ ] AI 替代传统 CI 工具</strong><ul><li><input disabled="" type="checkbox"> AI-agent 替代 Jenkins 的可行性研究 [参考：<a href="https://www.jenkins.io/doc/book/ai/]">https://www.jenkins.io/doc/book/ai/]</a></li><li><input disabled="" type="checkbox"> 智能构建优化（依赖分析、缓存策略） [参考：<a href="https://github.com/GoogleContainerTools/kaniko]">https://github.com/GoogleContainerTools/kaniko]</a></li><li><input disabled="" type="checkbox"> 自动测试用例生成 [参考：<a href="https://github.com/microsoft/Codex-CI]">https://github.com/microsoft/Codex-CI]</a></li></ul></li><li><strong>[ ] 智能部署</strong><ul><li><input disabled="" type="checkbox"> 基于 AI 的部署策略优化 [参考：<a href="https://www.kubeflow.org/]">https://www.kubeflow.org/]</a></li><li><input disabled="" type="checkbox"> 自动回滚机制 [参考：<a href="https://argo-cd.readthedocs.io/en/stable/]">https://argo-cd.readthedocs.io/en/stable/]</a></li><li><input disabled="" type="checkbox"> 多环境配置管理 [参考：<a href="https://www.terraform.io/]">https://www.terraform.io/]</a></li></ul></li></ul><h3 id="3-AI-运维监控"><a href="#3-AI-运维监控" class="headerlink" title="3. AI 运维监控"></a>3. AI 运维监控</h3><ul><li><strong>[ ] 智能告警</strong><ul><li><input disabled="" type="checkbox"> 异常检测与根因分析 [参考：<a href="https://prometheus.io/docs/alerting/latest/overview/]">https://prometheus.io/docs/alerting/latest/overview/]</a></li><li><input disabled="" type="checkbox"> 告警降噪与聚合 [参考：<a href="https://grafana.com/docs/grafana/latest/alerting/]">https://grafana.com/docs/grafana/latest/alerting/]</a></li><li><input disabled="" type="checkbox"> 预测性维护 [参考：<a href="https://www.splunk.com/en_us/blog/learn/predictive-maintenance.html]">https://www.splunk.com/en_us/blog/learn/predictive-maintenance.html]</a></li></ul></li><li><strong>[ ] 日志分析</strong><ul><li><input disabled="" type="checkbox"> 日志模式识别 [参考：<a href="https://www.elastic.co/guide/en/machine-learning/current/ml-overview.html]">https://www.elastic.co/guide/en/machine-learning/current/ml-overview.html]</a></li><li><input disabled="" type="checkbox"> 异常行为检测 [参考：<a href="https://github.com/elastic/detection-rules]">https://github.com/elastic/detection-rules]</a></li><li><input disabled="" type="checkbox"> 自动生成运维报告 [参考：<a href="https://www.datadoghq.com/]">https://www.datadoghq.com/]</a></li></ul></li></ul><h3 id="4-AI-基础设施管理"><a href="#4-AI-基础设施管理" class="headerlink" title="4. AI 基础设施管理"></a>4. AI 基础设施管理</h3><ul><li><strong>[ ] 资源优化</strong><ul><li><input disabled="" type="checkbox"> 自动扩缩容策略 [参考：<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/]">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/]</a></li><li><input disabled="" type="checkbox"> 成本优化建议 [参考：<a href="https://cloud.google.com/recommender]">https://cloud.google.com/recommender]</a></li><li><input disabled="" type="checkbox"> 资源利用率分析 [参考：<a href="https://github.com/kubernetes-sigs/metrics-server]">https://github.com/kubernetes-sigs/metrics-server]</a></li></ul></li><li><strong>[ ] 安全防护</strong><ul><li><input disabled="" type="checkbox"> 异常流量检测 [参考：<a href="https://www.crowdstrike.com/]">https://www.crowdstrike.com/]</a></li><li><input disabled="" type="checkbox"> 容器运行时安全 [参考：<a href="https://falco.org/]">https://falco.org/]</a></li><li><input disabled="" type="checkbox"> 漏洞扫描与修复建议 [参考：<a href="https://github.com/aquasecurity/trivy]">https://github.com/aquasecurity/trivy]</a></li></ul></li></ul><h3 id="5-AI-协作与知识管理"><a href="#5-AI-协作与知识管理" class="headerlink" title="5. AI 协作与知识管理"></a>5. AI 协作与知识管理</h3><ul><li><strong>[ ] ChatOps</strong><ul><li><input disabled="" type="checkbox"> 基于 AI 的运维对话系统 [参考：<a href="https://github.com/slackapi/python-slack-sdk]">https://github.com/slackapi/python-slack-sdk]</a></li><li><input disabled="" type="checkbox"> 自然语言处理运维指令 [参考：<a href="https://github.com/RasaHQ/rasa]">https://github.com/RasaHQ/rasa]</a></li><li><input disabled="" type="checkbox"> 知识库自动更新 [参考：<a href="https://github.com/facebookresearch/faiss]">https://github.com/facebookresearch/faiss]</a></li></ul></li><li><strong>[ ] 团队协作</strong><ul><li><input disabled="" type="checkbox"> 智能任务分配 [参考：<a href="https://asana.com/]">https://asana.com/]</a></li><li><input disabled="" type="checkbox"> 知识共享与传承 [参考：<a href="https://www.notion.so/]">https://www.notion.so/]</a></li><li><input disabled="" type="checkbox"> 自动化文档协作 [参考：<a href="https://www.gitbook.com/]">https://www.gitbook.com/]</a></li></ul></li></ul><hr><h2 id="二、作为后端-工程化能力"><a href="#二、作为后端-工程化能力" class="headerlink" title="二、作为后端 工程化能力"></a>二、作为后端 工程化能力</h2><h3 id="1-Python-开发"><a href="#1-Python-开发" class="headerlink" title="1. Python 开发"></a>1. Python 开发</h3><h3 id="1-1-Python-深入学习-进度-40"><a href="#1-1-Python-深入学习-进度-40" class="headerlink" title="1.1 Python 深入学习 [进度: 40%]"></a>1.1 Python 深入学习 [进度: 40%]</h3><ul><li><strong>[x] Python 基础</strong>（已完成语法学习）  </li><li><strong>[ ] Flask&#x2F;Django 进阶</strong>  <ul><li><input disabled="" type="checkbox"> RESTful API 设计（Swagger 文档化）  </li><li><input disabled="" type="checkbox"> 认证系统（JWT&#x2F;OAuth2 集成）  </li><li><input disabled="" type="checkbox"> 性能优化（gunicorn 多进程配置）</li></ul></li><li><strong>[ ] 异步编程</strong>  <ul><li><input disabled="" type="checkbox"> Celery 分布式任务队列  </li><li><input disabled="" type="checkbox"> asyncio 协程应用</li></ul></li><li><strong>[ ] 源码分析专题</strong>  <ul><li><input disabled="" type="checkbox"> Flask 源码：HTTP 请求处理、路由机制  </li><li><input disabled="" type="checkbox"> Requests 源码：HTTP 库设计  </li><li><input disabled="" type="checkbox"> 内置模块实现（json、collections）</li></ul></li><li><strong>[ ] 版本特性对比</strong>  <ul><li><input disabled="" type="checkbox"> Python 各版本差异对比：关注常用特性变更和性能提升</li></ul></li><li><strong>[ ] 框架深入</strong>  <ul><li><input disabled="" type="checkbox"> Flask&#x2F;FastAPI&#x2F;Django 框架深入  </li><li><input disabled="" type="checkbox"> ORM 与数据库优化  </li><li><input disabled="" type="checkbox"> RESTful API 设计  </li><li><input disabled="" type="checkbox"> 认证与权限系统  </li><li><input disabled="" type="checkbox"> Django 框架入门：安装配置、路由与模型管理  </li><li><input disabled="" type="checkbox"> Django REST framework：创建 API，Token 认证、权限配置</li></ul></li><li><input disabled="" type="checkbox"> Flask 标准开发流程：项目结构、扩展使用（如 SQLAlchemy、Flask-Login）</li></ul><h3 id="2-前端工具开发"><a href="#2-前端工具开发" class="headerlink" title="2. 前端工具开发"></a>2. 前端工具开发</h3><ul><li><strong>[x] React 基础</strong>（已完成组件开发）  </li><li><strong>[ ] Next.js 进阶</strong>  <ul><li><input disabled="" type="checkbox"> 服务端渲染（SSR）优化  </li><li><input disabled="" type="checkbox"> API Routes 开发  </li><li><input disabled="" type="checkbox"> 与 Python 后端联调</li></ul></li></ul><h3 id="3-系统设计"><a href="#3-系统设计" class="headerlink" title="3. 系统设计"></a>3. 系统设计</h3><ul><li><strong>[ ] 分布式系统</strong>  <ul><li><input disabled="" type="checkbox"> 一致性协议（Raft&#x2F;Paxos）  </li><li><input disabled="" type="checkbox"> 分布式锁实现（基于 Redis&#x2F;Zookeeper）</li></ul></li><li><strong>[ ] 消息队列</strong>  <ul><li><input disabled="" type="checkbox"> Kafka 分区与副本机制  </li><li><input disabled="" type="checkbox"> 消息可靠性投递（Exactly-Once 语义）</li></ul></li></ul><h3 id="4-部署"><a href="#4-部署" class="headerlink" title="4. 部署"></a>4. 部署</h3><ul><li><input disabled="" type="checkbox"> uWSGI&#x2F;Gunicorn + Nginx 部署：配置反向代理，环境变量管理，性能调优</li></ul><hr><h2 id="三、通用基础"><a href="#三、通用基础" class="headerlink" title="三、通用基础"></a>三、通用基础</h2><h3 id="1-操作系统与网络"><a href="#1-操作系统与网络" class="headerlink" title="1. 操作系统与网络"></a>1. 操作系统与网络</h3><ul><li><strong>[x] Linux 基础</strong>（已完成日常操作）  </li><li><strong>[ ] Linux 高级</strong>  <ul><li><input disabled="" type="checkbox"> 性能调优（sysctl 参数调整）  </li><li><input disabled="" type="checkbox"> 内核机制（cgroups&#x2F;namespaces）</li></ul></li><li><strong>[x] HTTP&#x2F;TCP 协议</strong>（已读《图解HTTP》《图解TCP&#x2F;IP》）  </li><li><strong>[ ] 网络排障</strong>  <ul><li><input disabled="" type="checkbox"> tcpdump&#x2F;Wireshark 抓包分析  </li><li><input disabled="" type="checkbox"> 模拟网络延迟&#x2F;丢包（tc 命令）</li></ul></li></ul><h3 id="2-算法与数据结构"><a href="#2-算法与数据结构" class="headerlink" title="2. 算法与数据结构"></a>2. 算法与数据结构</h3><ul><li><strong>[ ] LeetCode 专项</strong>（特斯拉常考题型）  <ul><li><input disabled="" type="checkbox"> 字符串处理（滑动窗口）  </li><li><input disabled="" type="checkbox"> 树结构遍历（DFS&#x2F;BFS）  </li><li><input disabled="" type="checkbox"> 动态规划（背包问题变种）</li></ul></li></ul><h3 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h3><ul><li><strong>[ ] PostgreSQL 优化</strong>  <ul><li><input disabled="" type="checkbox"> 执行计划分析（EXPLAIN ANALYZE）  </li><li><input disabled="" type="checkbox"> 连接池配置（PgBouncer）</li></ul></li><li><strong>[ ] Redis 高级</strong>  <ul><li><input disabled="" type="checkbox"> 持久化策略（RDB&#x2F;AOF）  </li><li><input disabled="" type="checkbox"> 集群模式（Redis Cluster）</li></ul></li></ul><!-- ### 5.1 关系型数据库 [进度: 20%]- [x] MySQL 基础操作- [ ] PostgreSQL 深入学习  - [ ] 高级查询优化  - [ ] 集群部署- [ ] 数据库设计  - [ ] 范式理论  - [ ] 分库分表  - [ ] 索引优化  - [ ] 事务与并发控制  - [ ] 备份与恢复  - [ ] 监控与报警  - [ ] 性能调优  - [ ] 主从复制  - [ ] 读写分离### 5.2 NoSQL数据库 [进度: 10%]- [x] Redis 基础使用- [ ] MongoDB 学习- [ ] Elasticsearch 实践- [ ] 缓存设计与优化- [ ] MySQL 语法与操作：基础 SQL 查询，索引优化- [ ] MySQL 事务与一致性：锁机制、事务隔离级别- [ ] MySQL 引擎深入：InnoDB 与 MyISAM 特性比较- [ ] Elasticsearch 核心概念：索引、分片、查询分析- [ ] Elasticsearch 配置优化：节点配置、集群管理、性能优化 --><hr><h2 id="四、作为-DevOps-核心技能"><a href="#四、作为-DevOps-核心技能" class="headerlink" title="四、作为 DevOps 核心技能"></a>四、作为 DevOps 核心技能</h2><h3 id="1-容器与编排"><a href="#1-容器与编排" class="headerlink" title="1. 容器与编排"></a>1. 容器与编排</h3><ul><li><strong>[x] Kubernetes 基础操作</strong>（已完成业务环境实践）  </li><li><strong>[ ] Kubernetes 高级主题</strong>  <ul><li><input disabled="" type="checkbox"> 核心组件原理（API Server、etcd、kube-proxy）  </li><li><input disabled="" type="checkbox"> 多集群管理（跨数据中心部署）  </li><li><input disabled="" type="checkbox"> 故障排查（Pod 状态异常、网络策略冲突）  </li><li><input disabled="" type="checkbox"> 滚动更新&#x2F;回滚策略</li></ul></li><li><strong>[x] Docker 基础操作</strong>（已完成业务环境实践 + 本地 nas 使用 portainer 管理）  – 2025.2</li><li><strong>[ ] Docker 深入</strong>  <ul><li><input disabled="" type="checkbox"> 多阶段构建优化镜像体积  </li><li><input disabled="" type="checkbox"> 容器网络模型（bridge&#x2F;host&#x2F;none）  </li><li><input disabled="" type="checkbox"> 存储卷生命周期管理</li></ul></li></ul><h3 id="2-CI-CD-工具链"><a href="#2-CI-CD-工具链" class="headerlink" title="2. CI&#x2F;CD 工具链"></a>2. CI&#x2F;CD 工具链</h3><ul><li><strong>[x] Jenkins 基础</strong>（已完成流水线搭建）  </li><li><strong>[ ] Jenkins 高级</strong>  <ul><li><input disabled="" type="checkbox"> 参数化流水线（动态环境部署）  </li><li><input disabled="" type="checkbox"> 与 Kubernetes 集成（Jenkins on K8s）  </li><li><input disabled="" type="checkbox"> 安全加固（凭据管理、RBAC）</li></ul></li><li><strong>[ ] Argo CD 与 GitOps</strong>  <ul><li><input disabled="" type="checkbox"> 声明式部署流程  </li><li><input disabled="" type="checkbox"> 多环境配置管理（dev&#x2F;staging&#x2F;prod）</li></ul></li><li><strong>[ ] 制品管理</strong>  <ul><li><input disabled="" type="checkbox"> Artifactory&#x2F;Nexus 私有仓库搭建  </li><li><input disabled="" type="checkbox"> 镜像扫描与漏洞检测</li></ul></li></ul><h3 id="3-基础设施即代码（IaC）"><a href="#3-基础设施即代码（IaC）" class="headerlink" title="3. 基础设施即代码（IaC）"></a>3. 基础设施即代码（IaC）</h3><ul><li><strong>[x] Ansible 基础</strong>（已完成配置管理）  </li><li><strong>[ ] Terraform 深入</strong>  <ul><li><input disabled="" type="checkbox"> AWS&#x2F;GCP 云资源编排  </li><li><input disabled="" type="checkbox"> 模块化设计（复用代码库）  </li><li><input disabled="" type="checkbox"> 状态文件安全管理</li></ul></li></ul><h3 id="4-监控与日志"><a href="#4-监控与日志" class="headerlink" title="4. 监控与日志"></a>4. 监控与日志</h3><ul><li><strong>[ ] Prometheus + Grafana</strong>  <ul><li><input disabled="" type="checkbox"> 自定义指标采集（Exporter 开发）  </li><li><input disabled="" type="checkbox"> 报警规则配置（如 Pod OOM 预警）</li></ul></li><li><strong>[ ] ELK&#x2F;OpenSearch</strong>  <ul><li><input disabled="" type="checkbox"> 日志收集管道设计  </li><li><input disabled="" type="checkbox"> 高性能索引策略</li></ul></li></ul><h3 id="5-生产环境专项"><a href="#5-生产环境专项" class="headerlink" title="5. 生产环境专项"></a>5. 生产环境专项</h3><ul><li><strong>[ ] 高可用架构</strong>  <ul><li><input disabled="" type="checkbox"> 多活数据中心设计  </li><li><input disabled="" type="checkbox"> 故障转移演练</li></ul></li><li><strong>[ ] 安全合规</strong>  <ul><li><input disabled="" type="checkbox"> 容器运行时安全（Falco）  </li><li><input disabled="" type="checkbox"> 网络策略（Calico 规则配置）</li></ul></li></ul><!-- ### 1.3 Go- [ ] Go 语言基础：语法、并发模型（goroutines、channels）- [ ] Go 语言标准库：net/http、context、sync 等- [ ] Go 语言项目结构：模块化、依赖管理- [ ] Go 语言构建工具：go build、go mod --><!-- ### 1.6 其他- [ ] Java Spring Boot 入门：依赖注入、REST API、数据库集成- [ ] Java Gradle 构建流程：项目配置、依赖管理、打包 --><!-- ## 2 计算机基础 [进度: 30%]### 2.1 操作系统- [ ] Linux 内核：进程管理、文件系统、网络管理的基础知识- [ ] Linux 性能调优：理解常用内核参数，调整网络、内存优化系统性能### 2.2 网络- [x] HTTP 协议：请求头与响应头，状态码，HTTPS 原理 (看完《图解HTTP》)  -- 2024.10- [x] TCP/IP 轮廓了解  (看完《图解TCP/IP》，现阶段任务够了)  -- 2024.10- [ ] TCP/IP 协议族，重点学习： TCP 三次握手、四次挥手、UDP 差异 （等业务上用得到再看吧）- [ ] Socket 编程：使用 Python/C 进行简单 Socket 通信编程### 2.3 计算机组成原理- [ ] 计算机组成原理：深入理解 CPU、内存、IO 子系统的基本原理### 2.4 系统设计- [ ] 系统设计：深入理解系统设计原则，掌握设计模式### 2.5 分布式- [ ] 分布式：深入理解分布式系统设计，掌握分布式事务、负载均衡、缓存策略### 2.6 高并发- [ ] 高并发：深入理解高并发系统设计，掌握限流、熔断、降级等策略### 2.7 高可用- [ ] 高可用：深入理解高可用系统设计，掌握故障恢复、监控报警等策略- [x] HTTP/HTTPS 协议（完成《图解HTTP》）- 2024.10- [x] TCP/IP 基础（完成《图解TCP/IP》）- 2024.10- [ ] 操作系统原理- [ ] Linux 内核与性能调优### 6. 系统架构 [总进度: 20%]### 6.1 微服务架构 [进度: 25%]- [x] 服务拆分原则- [ ] 服务发现  - [ ] Consul  - [ ] Etcd- [ ] API 网关  - [ ] Kong  - [ ] Traefik### 6.2 消息队列 [进度: 15%]- [x] RabbitMQ 基础- [ ] Kafka 深入学习- [ ] 消息模式设计### 7. 安全与性能 [总进度: 10%]### 7.1 应用安全 [进度: 15%]- [x] HTTPS/TLS- [ ] OAuth2.0/JWT- [ ] 安全漏洞防护  - [ ] XSS  - [ ] CSRF  - [ ] SQL注入### 7.2 性能优化 [进度: 5%]- [ ] 代码级优化- [ ] 系统级优化- [ ] 数据库优化- [ ] HTTPS 与 SSL/TLS：加密原理，CA 证书，握手过程- [ ] 常见加密算法：AES、RSA、SHA 算法学习- [ ] 《图解密码技术》阅读：了解基础加密概念与应用场景## 8. 数据科学与大数据### 8.1 AI 与数据科学- [ ] 机器学习基础：监督学习、无监督学习、常用算法- [ ] PyTorch / TensorFlow 使用：张量操作、自动微分、神经网络训练### 8.2 大数据技术- [ ] Hadoop 基础使用：HDFS、MapReduce 原理- [ ] Spark 快速上手：数据操作、RDD、DataFrame、数据处理案例 --><h1 id="学习时间规划"><a href="#学习时间规划" class="headerlink" title="学习时间规划"></a>学习时间规划</h1><table><thead><tr><th>阶段</th><th>预计时间</th><th>优先级</th><th>状态</th><th>完成时间</th></tr></thead><tbody><tr><td>Python 源码分析</td><td>3个月</td><td>P1</td><td>进行中</td><td>-</td></tr><tr><td>K8s 深入学习</td><td>2个月</td><td>P0</td><td>已完成</td><td>2024.12</td></tr><tr><td>HTTP&#x2F;TCP学习</td><td>1个月</td><td>P1</td><td>已完成</td><td>2024.10</td></tr><tr><td>CI&#x2F;CD 工具链</td><td>2个月</td><td>P1</td><td>进行中</td><td>-</td></tr></tbody></table><h1 id="进度更新记录"><a href="#进度更新记录" class="headerlink" title="进度更新记录"></a>进度更新记录</h1><h2 id="已完成项目"><a href="#已完成项目" class="headerlink" title="已完成项目"></a>已完成项目</h2><ul><li><input checked="" disabled="" type="checkbox"> Kubernetes 集群搭建与管理 (2024.12)</li><li><input checked="" disabled="" type="checkbox"> HTTP&#x2F;HTTPS 协议学习 (2024.10)</li><li><input checked="" disabled="" type="checkbox"> TCP&#x2F;IP 基础知识掌握 (2024.10)</li><li><input checked="" disabled="" type="checkbox"> React 基础组件开发</li><li><input checked="" disabled="" type="checkbox"> Jenkins CI&#x2F;CD 基础配置</li></ul><h2 id="进行中项目"><a href="#进行中项目" class="headerlink" title="进行中项目"></a>进行中项目</h2><ul><li><input disabled="" type="checkbox"> Python 源码分析系列</li><li><input disabled="" type="checkbox"> Docker 深入学习</li><li><input disabled="" type="checkbox"> 监控系统搭建</li></ul><h2 id="计划中项目"><a href="#计划中项目" class="headerlink" title="计划中项目"></a>计划中项目</h2><ul><li><input disabled="" type="checkbox"> Vue 技术栈学习</li><li><input disabled="" type="checkbox"> ELK 日志分析系统</li><li><input disabled="" type="checkbox"> 代码质量管理平台</li></ul><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li>《图解HTTP》(已读完)</li><li>《图解TCP&#x2F;IP》(已读完)</li><li>《图解密码技术》(计划中)</li></ul><h2 id="在线资源"><a href="#在线资源" class="headerlink" title="在线资源"></a>在线资源</h2><ul><li><a href="https://docs.python.org/3/">Python 官方文档</a></li><li><a href="https://kubernetes.io/docs/">Kubernetes 官方文档</a></li><li><a href="https://docs.docker.com/">Docker 官方文档</a></li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>保持学习节奏：每周至少投入20小时</li><li>注重实践：每个模块都要有实际项目</li><li>及时复习：每月回顾一次学习内容</li><li>记录笔记：建立知识体系</li></ol><h1 id="Abandoned"><a href="#Abandoned" class="headerlink" title="Abandoned"></a>Abandoned</h1><ul><li>Selenium 异步标签页池：使用 Puppeteer&#x2F;Playwright 完成，避免业务耦合。</li><li>StudyFlow 可视化技能树项目：<ol><li>先将需要打卡的知识点放到一个 data.json</li><li>再使用 Echarts 渲染一个棵 js 代码中表达的树</li><li>进而在 markdown 中被引用</li><li>同时使用 Puppeteer 渲染这段 js 代码，将生成的这棵树的 .png 文件保存到 source&#x2F;images 目录下，能够用做文章头图，或者被首页引用</li><li>至于打卡部分，就使用 iOS 原生的日历app，再定期总结规划即可，没有必要非要形式上搞一个前后端工程</li></ol></li></ul><!-- 原有的注释保留 -->]]></content>
    
    
    
    <tags>
      
      <tag>Skill</tag>
      
      <tag>AIOps</tag>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/04/hello-world/"/>
    <url>/2025/02/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在工作6年之际总结业务与技能点</title>
    <link href="/2024/05/18/career/review-2024/"/>
    <url>/2024/05/18/career/review-2024/</url>
    
    <content type="html"><![CDATA[<p>再也不是毕业在即两眼一黑，更不是初入职场惶恐不安的状态了。<br>不知不觉已经6年工作六年，在3年的时候拍了<a href="https://www.bilibili.com/video/BV1b7411B7YR">第一个 vlog </a>，那个时候说三年应该跨过新手期，深耕一个领域，现在看来没有辜负当时的期待。<br>迄今，我的职业生涯从成都小公司做 python 后端 + 爬虫，经过深圳上海做 效能 &#x2F; DevOps，现在定居上海，基本快完成从小就“想进入世界一流公司的梦想”了。</p><span id="more"></span><h1 id="迷茫的学生时代"><a href="#迷茫的学生时代" class="headerlink" title="迷茫的学生时代"></a>迷茫的学生时代</h1><p>中学就在开始参加竞赛，但基于我懒散随性的性格，也没搞出什么名堂，当时某个拿满分的队友，毕业就进入当时还没有那么出名的字节跳动（当时好像还叫头条），我却连自己能不能进入这个行业都在怀疑。</p><p>大学的时候曾有机会跟着老师做地质相关的图形图像处理，最后也只夸夸其谈没有坚持下来。<br>临近毕业还去面试完美世界的客服，回过头来还是觉得当时太浮躁了。</p><h1 id="惶恐的初入职场"><a href="#惶恐的初入职场" class="headerlink" title="惶恐的初入职场"></a>惶恐的初入职场</h1><p>没有参与校招，前三份工作都是成都的（符合对西南柬埔寨刻板印象的）小公司，可以说我的起点很低了。<br>符合城情的试用期不买社保，根本不存在的职业规划和晋升途径。在我多次痛苦挣扎之后均都在差不多第3个月的时候跑路，导致我当时的简历乱七八糟，向未来能看到的只有迷雾。</p><p>摸索中学到了：<br>1st ： python 后端开发， 团队职业分工，调用别人 api；<br>2nd ： 网页模拟点击操作， 爬虫， 开放 api， 封装代码， 数据展示相关的 dashboard；<br>3st ： 权责分明， 破除名校光环， 职场自保， 对梦想的方向坚定不移；</p><h1 id="辗转的适应社会"><a href="#辗转的适应社会" class="headerlink" title="辗转的适应社会"></a>辗转的适应社会</h1><p>挣扎过后觉得日子不能这样过下去了。几经波折找到成都一家正规的做机票代理的公司。</p><p><strong>成都公司</strong>： docker 打包， restful api， 微服务，多线程，重构代码。</p><p>再后来就是疫情来了被裁，发现成都根本找不到工作，然后接到了深圳一家上市公司的 offer ，现在无时不刻不在觉得这是一个影响深远的决定。</p><p>到了深圳公司。<br>一开始业务是在测试开发相关，是让我解决 过量膨胀的 testcase 的问题，加上探索新一代的 testcase runner（基于 nlp, cv, or ?），以及作为甲方私有化地部署购买的服务；<br>随着业务的发展，进而为开始搭建 客户端app 流水线，维护物理agent机器，以及串起来 CI 相关的各种组建，再加上 CD 相关的服务；</p><p><strong>深圳公司</strong>： Jenkins， php， vue， cicd。</p><p>一个机缘巧合下来上海了，又是一个全新的领域，虽然岗位还是叫 DevOps，但是按照某些公司的定位应该是 SRE，即我认为的“线上稳定性保证”。</p><p><strong>上海公司</strong>：kubernetes， 云服务商，continuous development， 发版平台。</p><h1 id="成熟且明确的规划"><a href="#成熟且明确的规划" class="headerlink" title="成熟且明确的规划"></a>成熟且明确的规划</h1><p>也是一个缘分，被上家公司裁员之后，本来拿出了半年准备面试，结果没几天接到的第三个 offer 就感觉挺合适的，就直接去了，社保都无缝衔接。</p><p>背景相当于本来有一个团队负责类似 客户端 &#x2F; 大前端 cicd 这种业务线，然后整个团队都没了。<br>于是在开始的半年我就用了近乎全部的精力去当客服，少的时候几十个，多的时候同时面对上百个人的同步咨询。<br>还能用的服务，把文档和使用文档整理出来；不能用的服务，排期进行恢复。<br>那段时间压力非常大，总会有几个人同步的消息请求过来，不管是去处理谁的事情了，总有人没法得到相应。经常凌晨四五点就醒了睡不着，主要是人只有一个，要做的事情却太杂了。</p><p>现在很多同事经常都和我打趣说不知道我当时是怎么扛下来的，以及当时终于盼来我之后，经常看我状态是否是 （已跑路）。<br>当时下至一线同事，上至HRBP看到我来了都笑嘻嘻地表示终于有人填坑。<br>很多业务开发同事开始报复性提需求，也经常把我当客服发泄自己搞不定又根本不该我管的来分散我的精力。<br>多亏了当时的领导，帮我挡下了很多不合理的需求，以及授权我在文档详实的情况下拒绝同事期待的手把手帮教写代码的无理需求。</p><p>接下来做了一次组织架构调整，也招到了人，终于才能有时间看看 《深入理解计算机系统》；<br>点一下从成都正规公司就早有耳闻的 Goland 技能点。</p><p>我现在也算有了相对清晰的职业规划。<br>首先我真的是一个不挑业务的人，不知道为什么总有人听到我说这个的时候会感到诧异，工作这么多年，哪次不是收拾行囊进入新的业务领域，不都是软件开发工程么，有的只是业务上的区别。<br>其次大方向是 内部平台（或者说所谓的中台），不管是所谓的发版平台，效能 统计 &#x2F; 展示 &#x2F; 运维 &#x2F; 自动化平台，或者说 all in one 的 CICD 流水线平台开发；<br>亦或者 云上 SRE k8s 这一套。<br>这些都是我多年的业务经验领域，比较熟悉了，出现新的工具上手也很快。<br>当然如果让我回去做测开也是一样的，因为我始终觉得 测试，或者说质量保证是 效能 &#x2F; DevOps 很重要的一环。<br>最后我是真的不挑业务，有机会做什么大数据，AI相关开发当然更好。</p><p>随着 Copilot &#x2F; ChatGPT 的普及，技术上手门槛只会越来越低，像刚毕业那会儿学个新东西还是翻文档，再在耐不住的时候狂看相关视频，痛苦地搞个个把月，但现在直接就可以上手业务代码，一边翻译一边询问，哪怕是从来没有用过的语言，在见多识广的 AI 帮助下，直接先写项目。<br>等积累了一定经验，再回头系统的找资料学习，先不说提升的效率，基本上都不再会有以前那种需要摸索找切入点，然后痛苦的在繁杂而陌生的知识图谱中打转的学习状态了。</p>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevOps Toolchain Integration Setup</title>
    <link href="/2023/04/30/devops/devops_toolchain_integration/"/>
    <url>/2023/04/30/devops/devops_toolchain_integration/</url>
    
    <content type="html"><![CDATA[<h1 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h1><p>作为个人工作中实际用到的DevOps相关工具链的整合搭建，同时也作为新手上手DevOps的Quick Setup。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>长话短说:</p><ul><li><p>数据分析师: 作为一名<strong>数学专业</strong>的划水学生，毕业之后无比<strong>憧憬</strong>能成为一名“数据分析师”，然后被<strong>忽悠</strong>到“信老师”（化名，具体内容可以参见<a href="https://www.bilibili.com/video/BV1Wv411b7Gm">我的一个视频总结</a>）旗下工作；</p></li><li><p>爬虫：老师告诉我，<strong>数据平台还没搭建好</strong>，这样吧，你先自己去<strong>公网上爬取数据</strong>；</p></li><li><p>爬虫 *2： 第一份正式的工作，技术栈是<strong>自动化</strong>的请求接口 &#x2F; <strong>操作浏览器界面</strong>完成业务；</p></li><li><p>测试开发 + DevOps：凭借上述后者，找到了<strong>UI自动化测试开发</strong>的工作；再在工作中要用到<strong>整合流水线</strong>为业务开发同事提供服务，于是职位变成了DevOps；</p></li><li><p>DevOps：来到上海成为专职DevOps，负责Daily CI&#x2F;CD &amp; Release platform 的搭建。</p></li></ul><p>之前的工作中部分组件是我去的时候已经安装、配置好了的，因此在这里把用到的工具链进行全流程的安装，回顾并系统的梳理技术栈，同时也作为新手上手DevOps的Quick Setup。</p><span id="more"></span><h1 id="机器"><a href="#机器" class="headerlink" title="机器"></a>机器</h1><p>Ubuntu 实体机 *2 （不要用WSL）</p><p>一个作为master，另一个作为node，搭建一个最小的集群。</p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p>之前业务上主要使用的是阿里云容器服务Kubernetes版（Alibaba Cloud Container Service for Kubernetes，简称容器服务ACK）</p><p>同时在私有化部署的时候使用<a href="https://kubesphere.io/zh/">kubesphere</a>，本文主要使用后者进行物理机上的部署。</p><p><a href="https://gou7ma7.github.io/2023/05/11/devops/Kubernetes/">Kubernetes Setup in Local Physical Servers</a></p><h1 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h1><p>The package manager for Kubernetes</p><p>简单来说，我的包管理方式经过一下迭代</p><ol><li>exe &#x2F; other executable file &#x2F; tar &amp; scp;</li><li>Docker Image;</li><li>Helm Charts;</li></ol>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不要用WSL，否则会变得不幸</title>
    <link href="/2023/04/30/devops/no_wsl/"/>
    <url>/2023/04/30/devops/no_wsl/</url>
    
    <content type="html"><![CDATA[<p>有位前辈用“Linux本身不要钱，但是你（折腾）的时间更费钱”来形容Linux上可能遇到的适配问题，从而表达自己对该系统又爱又恨的感情。</p><p>而寄宿在Windows上的WSL，更是将这个说法发挥到极致。</p><p>在我自己从头搭建Kubernetes工具链的时候，由于家境贫寒，本想就着手上4台老旧PC搭建个基本能用的集群就行，结果在Windows里面装WSL，以及WSL里面装Kubernetes的时候，遇到太多看不到尽头的问题，遂放弃。</p><p>目前我的解决方案是安装Ubuntu系统到其中2台PC，至少先跑起来一个最小的主从集群。</p><p>而本次我本身就是为了学习才搭建环境，因此记录下遇到的WSL相关的问题，以便学有余力的时候更加透彻的掌握操作系统相关的知识。</p><span id="more"></span>``<h1 id="WSL的适用范围"><a href="#WSL的适用范围" class="headerlink" title="WSL的适用范围"></a>WSL的适用范围</h1><p>写写Python代码，搭建普通的前后端应用，WSL是非常合适的，甚至避免了在Windows上安装软件的麻烦事。</p><p>但是在涉及到底层的东西，比如说虚拟化、容器化、集群化等这种需要用到“网卡”之类硬件的配置的时候，WSL这类基于Hyper-v的“精简版”虚拟机就会变得缺胳膊少腿，有早年用过“番茄花园”这种精简版Windows打游戏然后缺少组件经历的朋友就能体会到我的感受。</p><h1 id="最好的是物理机，其次是真正的虚拟机"><a href="#最好的是物理机，其次是真正的虚拟机" class="headerlink" title="最好的是物理机，其次是真正的虚拟机"></a>最好的是物理机，其次是真正的虚拟机</h1><p>这几天我一直在满是坑的泥泞中匍匐，很多问题要么是没有通用解法，要么是试下来根本不管用。</p><p>最后学习阶段只推荐VMware、VirtualBox这种成熟得不能再成熟的真正的虚拟机，如果不信欢迎自行尝试。</p><h1 id="systemd与systemctl"><a href="#systemd与systemctl" class="headerlink" title="systemd与systemctl"></a>systemd与systemctl</h1><p>systemd是一个Linux系统的初始化系统和服务管理器;</p><p>而systemctl是systemd的一个命令行工具，用于控制systemd系统和服务管理器。</p><p>systemctl可以启动、停止、重启、重载、状态检查、启用或禁用系统服务。</p><p>WSL2本身是由Windows负责运行的，因此使用tree或ps命令时会看到根进程不是systemd，这将导致无法启动Linux系统服务的守护进程(deamon)。当我们执行systemctl命令的时候，会显示出我们的init system (PID 1)并非systemd，而是微软提供的init system。</p><p>即使在&#x2F;etc&#x2F;wsl.conf添加systemd&#x3D;true配置等操作也会有各种问题。</p><h2 id="service代替systemctl"><a href="#service代替systemctl" class="headerlink" title="service代替systemctl"></a>service代替systemctl</h2><p>虽然有些时候能够通过service代替systemctl，但是有些时候会出现<code>Failed to connect to bus: No such file or directory</code>的错误。</p><p>比如我跑一个自动安装docker &#x2F; 自动开启ssh的脚本的时候，由于源头默认提供的脚本是使用systemctl的，还是绕不开这个问题。</p><p>如果我去批量替换别人的脚本，又会带来新的问题。</p><h1 id="WSL2无法连接网络"><a href="#WSL2无法连接网络" class="headerlink" title="WSL2无法连接网络"></a>WSL2无法连接网络</h1><h2 id="Windows-automatically-generates-resolv-conf-file-with-wrong-nameserver"><a href="#Windows-automatically-generates-resolv-conf-file-with-wrong-nameserver" class="headerlink" title="Windows automatically generates resolv.conf file with wrong nameserver"></a>Windows automatically generates resolv.conf file with wrong nameserver</h2><p><a href="https://stackoverflow.com/questions/62314789/no-internet-connection-on-wsl-ubuntu-windows-subsystem-for-linux">https://stackoverflow.com/questions/62314789/no-internet-connection-on-wsl-ubuntu-windows-subsystem-for-linux</a><br>Locate the file by running the following command:</p><p><code>sudo vim /etc/resolv.conf</code></p><p>You will see the following in the file:</p><h1 id="This-file-was-automatically-generated-by-WSL-To-stop-automatic-generation-of-this-file-add-the-following-entry-to-etc-resolv-conf"><a href="#This-file-was-automatically-generated-by-WSL-To-stop-automatic-generation-of-this-file-add-the-following-entry-to-etc-resolv-conf" class="headerlink" title="This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to &#x2F;etc&#x2F;resolv.conf"></a>This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to &#x2F;etc&#x2F;resolv.conf</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># [network]</span><br><span class="hljs-comment"># generateResolvConf = false</span><br>nameserver xxx.xx.xx<br></code></pre></td></tr></table></figure><p>Change the nameserver value to 8.8.8.8 and save the file. You should now be able to connect to the internet.</p><h2 id="winsock"><a href="#winsock" class="headerlink" title="winsock"></a>winsock</h2><p><a href="https://github.com/microsoft/WSL/issues/3438#issuecomment-41051857">https://github.com/microsoft/WSL/issues/3438#issuecomment-41051857</a><br>Open Command Prompt as an Administrator and type these commands:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">netsh winsock reset <br>netsh int ip reset all<br>netsh winhttp reset proxy<br>ipconfig /flushdns<br>Reboot your machine.<br></code></pre></td></tr></table></figure><p>完成之后一定重启WSL，否则修改不生效。</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>WSL2可以直接用Windows的命令行直接进入，也可以通过VSCode的WSL插件直接本地连接WSL；</p><h2 id="无法Set-Bridge-Network"><a href="#无法Set-Bridge-Network" class="headerlink" title="无法Set Bridge Network"></a>无法Set Bridge Network</h2><p>在正统的虚拟机配置设置Bridge Network都是点一键就能拿完成的工作，我无法在WSL上完成，虽然各种教程都说在Windows上的Hyper-v管理器上设置一下就好了，但是如果真的是这样的话，就不会有这篇文章了。</p><h2 id="kex-exchange-identification-Connection-closed-by-remote-host"><a href="#kex-exchange-identification-Connection-closed-by-remote-host" class="headerlink" title="kex_exchange_identification: Connection closed by remote host"></a>kex_exchange_identification: Connection closed by remote host</h2><p>在WSL2中开启sshd服务之后，连接自己机器上的WSL2只需要通过<code>ssh localhost</code>就可以；</p><p>连接局域网中另一个PC物理机上的WSL2就会出现标题标错，还有更离谱的timeout，我尝试过很多，就没成功过（多半是因为上面Set Bridge Network没成功导致的）。</p><h1 id="Transport-endpoint-is-not-connected"><a href="#Transport-endpoint-is-not-connected" class="headerlink" title="Transport endpoint is not connected"></a>Transport endpoint is not connected</h1><p>导致这个问题的原因太多了，不断重启LxssManager服务可能会暂时可用一下，我就是被这个问题搞得彻底放弃的。</p><p>LxssManager是Windows 10中的一个服务，它支持运行本机ELF二进制文件。该服务提供在Windows上运行ELF二进制文件所需的基础结构。WSL是Windows Subsystem for Linux的缩写，它是一个允许在Windows 10上运行Linux二进制文件的兼容层。LxssManager是WSL的一部分，它负责管理WSL的Linux发行版。</p><h1 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h1><p>首先部署Kubernetes的机器不能开启swap，因为在写入虚拟内存的时候会影响性能和造成系统卡顿；</p><p>于是在实体机上只需要<code>sudo swapoff -a</code>简单一步的操作，在WSL上死活不起作用，推测是WSL的swap是由Windows上的某个专门负责虚拟化的服务进行配置的，然后由于问题太过偏门，尝试了之后没有找到轻松有效的方法。</p><h1 id="Ubuntu-桥接接入局域网固定IP"><a href="#Ubuntu-桥接接入局域网固定IP" class="headerlink" title="Ubuntu 桥接接入局域网固定IP"></a>Ubuntu 桥接接入局域网固定IP</h1><h2 id="入网方式"><a href="#入网方式" class="headerlink" title="入网方式"></a>入网方式</h2><p>一般虚拟机软件都提供多种网络模式，主要有：</p><p>NAT模式： 虚拟机没有直接接入局域网，和集群里面的Node宿主机互相ping不通，<strong>不选</strong></p><p>Bridged Adapter模式：即桥接模式，为虚拟机模拟出一个独立的网卡，有独立的IP地址接入局域网，<strong>选</strong></p><h2 id="固定IP"><a href="#固定IP" class="headerlink" title="固定IP"></a>固定IP</h2><p>当虚拟机使用桥接模式接入局域网之后，就和物理机Ubuntu的设置一样了。</p><p>Ubuntu 18.04 LTS之后的版本使用&#x2F;etc&#x2F;netplan&#x2F;下得文件来配置网络，我这里叫01-network-manager-all.yaml。</p><p>首先使用<code>ifconfig</code>查看当前机器的网络情况，找到桥接的网卡名称，我这里是<code>enp0s3</code>；</p><p>然后使用<code>sudo vim /etc/netplan/01-network-manager-all.yaml</code>打开配置文件，添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Let NetworkManager manage all devices on this system</span><br>network:<br>  ethernets:<br>    enp0s3:  <span class="hljs-comment">#配置的网卡的名称</span><br>      addresses: [192.168.31.50/24]  <span class="hljs-comment">#配置的静态ip地址和掩码</span><br>      dhcp4: no  <span class="hljs-comment">#关闭DHCP，如果需要打开DHCP则写yes</span><br>      optional: <span class="hljs-literal">true</span><br>      routes:<br>        - to: 0.0.0.0/0<br>          via: 192.168.31.1  <span class="hljs-comment">#网关地址</span><br>      nameservers:<br>         addresses: [192.168.31.1]  <span class="hljs-comment">#DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开</span><br>  version: 2<br>    <span class="hljs-comment"># renderer: NetworkManager</span><br>  renderer: networkd  <span class="hljs-comment">#指定后端采用systemd-networkd或者Network Manager</span><br></code></pre></td></tr></table></figure><p>networkd和NetworkManager都是用于管理网络接口的后端。networkd是systemd的一部分，它是一个轻量级的网络管理器，可以在Ubuntu 18.04及更高版本中使用。它使用Netplan配置文件来配置网络接口。NetworkManager是一个更高级的网络管理器，可以在Ubuntu 16.04及更高版本中使用。它提供了一个GUI界面，可以方便地配置网络接口。</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Setup in Local Physical Servers</title>
    <link href="/2023/04/30/devops/setup_kubernetes/"/>
    <url>/2023/04/30/devops/setup_kubernetes/</url>
    
    <content type="html"><![CDATA[<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>在我自己在作为一名初学者学习编程的时候，曾看到过一位前辈在知乎日报中写道：</p><p>他们当年学习编程痛苦在根本找不到参考资料，只能自己硬着头皮摸索前进，不过好处是每个方向的技术选型基本上是固定的，不会有纠结；</p><p>而现在的初学者在一开始学习编程，就会很容易迷失在面对浩如烟海的技术路线选择中，尤其是热门的方向，总有前人做好了各种版本的教程、工具，完全不知道从哪里开始。</p><p>在我一开始学习DevOps的时候背过官方推荐的minikube教程， 到后来也尝试过搭建轻量化的k3s环境，算上业务中的阿里云容器服务Kubernetes版（Alibaba Cloud Container Service for Kubernetes，简称容器服务ACK），最终发现“搭建环境”本身也是造轮子的一部分，对提高<strong>理解应用能力</strong>甚微。</p><p>因此本文选择最简单的一种方式：<br><a href="https://kubesphere.io/zh/docs/v3.3/quick-start/all-in-one-on-linux/">在 Linux 上以 All-in-One 模式安装 KubeSphere</a>（以下简称<strong>官方文档</strong>），直接最简化地安装，然后再在使用中进行学习，毕竟<strong>背诵任何的学习资料都不如自己动手部署一遍</strong>。</p><span id="more"></span><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文仅供学习使用，生产环境请使用云服务厂商提供的成熟的Kubernetes环境。</p><h1 id="Master-Node"><a href="#Master-Node" class="headerlink" title="Master Node"></a>Master Node</h1><p>Ubuntu 实体机 in roy-qtc6（有些时候master node的名字可能是这个），这是一台2013年刚上大学时候买的HASEE 神舟 精盾 K580S-i7D1，三千六就拿到当时平民级最强的CPU和显卡，甚至到10年后的今天不管是装Windows娱乐还是装Linux学习性能都充裕，对比一会儿提到的同龄人简直是扬我国威。</p><p>按照<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/all-in-one-on-linux/">官方文档</a>中的步骤进行安装。</p><p>由于kubernetes与kubesphere之间存在一个版本匹配问题，因此我这里直接使用example中推荐的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./kk create cluster --with-kubernetes v1.22.12 --with-kubesphere v3.3.2<br></code></pre></td></tr></table></figure><p>当运行上述命令时，会检查机器是否安装依赖。</p><p>  在我这台机器上，只需要预先手动安装conntrack socat ebtables ethtool，其他组件会自动安装。</p><pre><code class="hljs">`$ apt-get install conntrack socat ebtables ethtool`</code></pre><table><thead><tr><th>name</th><th>sudo</th><th>curl</th><th>openssl</th><th>ebtables</th><th>socat</th><th>ipset</th><th>ipvsadm</th><th>conntrack</th><th>chrony</th><th>docker</th><th>containerd</th><th>nfs client</th><th>ceph client</th><th>glusterfs client</th></tr></thead><tbody><tr><td>master</td><td>y</td><td>y</td><td>y</td><td>y</td><td>y</td><td></td><td></td><td>y</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>查看log会发现 在依次安装kubelet、kubectl、helm、kubecni、crictl、etcd、docker等，在之后的教程里，会解释组件的作用。</p><p>经过漫长的等待之后，当console中出现Welcome hints、ip地址与默认admin账号密码， 就表示Kubenets安装完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ Welcome to KubeSphere!<br></code></pre></td></tr></table></figure><p>这个时候可以登录<a href="http://ip:30880/dashboard">http://ip:30880/dashboard</a> 进行可视化操作。</p><p>以上安装过程基本上是一键安装，在物理机器与Ubuntu系统没有太大问题的情况下，一小时之内能完成。</p><p>如果要安装官方的Kubernetes Dashboard的话，还需要手动安装、并配置外部访问与账号，这些额外的概念无疑会在一开始极大的增加初学者的负担。</p><p>而这些步骤&#x2F;组件 <strong>KubeSphere全家桶</strong>全都集成了，让开发者将更多的经历集中在理解与应用k8s核心组件与部署业务代码上。</p><p>接下来可以跟着官方文档应用学习其中组件了。</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><h3 id="WARNING-FileExisting-ethtool-ethtool-not-found-in-system-path"><a href="#WARNING-FileExisting-ethtool-ethtool-not-found-in-system-path" class="headerlink" title="[WARNING FileExisting-ethtool]: ethtool not found in system path"></a>[WARNING FileExisting-ethtool]: ethtool not found in system path</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ apt-get install ebtables ethtool<br></code></pre></td></tr></table></figure><p>这两个依赖是必须的，但是官方文档中没有列出来。</p><h3 id="kubectl-Please-wait-for-the-installation-to-complete"><a href="#kubectl-Please-wait-for-the-installation-to-complete" class="headerlink" title="kubectl Please wait for the installation to complete"></a>kubectl Please wait for the installation to complete</h3><p>安装的一直卡在这个命令，推测可能是kube-system中的k8s自己的pod没有就绪，另外启动一个shell查询pod状况；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get pod -A<br>NAMESPACE           NAME                                           READY   STATUS    RESTARTS   AGE<br>...<br>kube-system         openebs-localpv-provisioner-57bbf864d5-zhl6k   0/1     Pending   0          26m<br>kubesphere-system   ks-installer-85d6fb8c97-mns4d                  0/1     Pending   0          26m<br></code></pre></td></tr></table></figure><p>查看其中一个pod的Events</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl describe pod openebs-localpv-provisioner-57bbf864d5-zhl6k -n kube-system<br>Name:           openebs-localpv-provisioner-57bbf864d5-zhl6k<br>...<br>Events:<br>  Type     Reason            Age                 From               Message<br>  ----     ------            ----                ----               -------<br>  Warning  FailedScheduling  97s (x35 over 36m)  default-scheduler  0/1 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io/master: &#125;, that the pod didn<span class="hljs-string">&#x27;t tolerate.</span><br></code></pre></td></tr></table></figure><p>发现openebs-localpv-provisioner与ks-installer的STATUS均是Pending，通过Events里面的描述，发现是因为有taints所以pod调度不上去。</p><p>查看node的taints</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get nodes -o json | jq <span class="hljs-string">&#x27;.items[].spec&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;taints&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;effect&quot;</span>: <span class="hljs-string">&quot;NoSchedule&quot;</span>,<br>      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;node-role.kubernetes.io/master&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;effect&quot;</span>: <span class="hljs-string">&quot;NoSchedule&quot;</span>,<br>      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;node.kubernetes.io/not-ready&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>means that no pod can be scheduled on the master node unless it has a toleration for this taint123， 意思就是说不能在master节点上的和not-ready的pod不允许调度到我这个节点上。</p><p>The OpenEBS Local PV provisioner is designed to run on worker nodes and not on master nodes1. If you want to deploy the OpenEBS Local PV provisioner on a master node, you can do so by adding the label openebs.io&#x2F;engine&#x3D;provisioner to the master node2. However, it is not recommended to run the provisioner on master nodes as it can cause issues with the Kubernetes control plane</p><p>污点（Taint）是 Kubernetes 中的一个概念，它是一种标记，用于标识节点上的一些特殊条件，例如节点上的硬件故障或其他不可用性。 污点可以阻止 Pod 调度到具有特定污点的节点上。 有关更多信息，请参见<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/">官方文档</a>。</p><p>Taints and Tolerations 是一起组合使用的，相当于“黑名单”机制，前者配置在nodes上，只能配置过后者的pod；</p><pre><code class="hljs">简单但是不推荐的做法： 将taints删除</code></pre><blockquote><p>:warning: <strong>不如直接用minikube单节点部署</strong>: 这里的意思是这个pod不能调度在master节点上，如果删了这个污点，相当于是强行调度在master上了。</p></blockquote><p>执行<code>kubectl taint nodes --all node-role.kubernetes.io/master-</code>, 这个命令是在将所有节点的node-role.kubernetes.io&#x2F;master 污点删除，以便可以在这些节点上调度非 master Pod。</p><p>然后发现唯一node上的taint没有了(这里换一个方法查看taints)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl describe node master | grep Taints<br>Taints:             &lt;none&gt;<br></code></pre></td></tr></table></figure><pre><code class="hljs">正规做法：先跳过这个pod的安装，参照下文先安装一个worker node并注册到cluster，然后再重复安装步骤安装。</code></pre><p>完成安装worker node并注册到cluster后，验证查看当前nodes</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get nodes<br>NAME             STATUS   ROLES                  AGE    VERSION<br>worker           Ready    worker                 9h     v1.22.12<br>master           Ready    control-plane,master   4d3h   v1.22.12<br></code></pre></td></tr></table></figure><p>当看到出现STATUS为Ready的worker时候，就可以再执行<code>./kk create cluster --with-kubernetes v1.22.12 --with-kubesphere v3.3.2</code>，然后经过漫长的等待即可。</p><h1 id="Worker-Node"><a href="#Worker-Node" class="headerlink" title="Worker Node"></a>Worker Node</h1><p>Ubuntu 实体机 in roy-macbookair（有些时候worker node的名字可能是这个），这是一台2013款的具有10年历史的老机器，陪我拿到了第一家上市公司的offer，但目前已经无法正常运行macOS，因此安装Ubuntu（图形化模式略微卡顿，使用命令行模式才能流畅运行k8s）。</p><p>按照<a href="https://kubesphere.io/zh/docs/v3.3/installing-on-linux/introduction/multioverview/">在 Linux 上多节点安装</a>中的步骤进行安装。</p><p>将一台新准备好的Linux物理机， 作为Node（不管Worker是Master）添加到cluster只需要KubeKey + SSH 就能完成。</p><p>那么同样地，先安装相关地依赖<br><code>$ apt install conntrack socat ebtables ethtool</code></p><p>然后在当前目录下创建一个config-sample.yaml的文件（这一步可以在新机器的终端上完成，也可也在已有集群的任意一个物理机的终端上完成）<br><code>$ ./kk create config</code></p><p>在我这里，config-sample.yaml的内容如下，其中的ssh相关的信息需要自己填写，这里我使用的是密码登录，因此需要填写密码，如果使用的是ssh key登录，则不需要填写密码（但是需要配置ssh-key）。</p><p>然后按照教程中的配置文件，结合自己的node name与ip，修改配置文件，然后执行<code>$ ./kk create cluster -f config-sample.yaml</code>（集群未安装）&#x2F; <code>/kk add nodes -f sample.yaml</code>（集群已安装），等待一段时间后，集群就安装好了。</p><p>在经过以上操作后，可以看到我成功的创建了一个一共拥有3个Node的Cluster，就可以开始自己的kubenets操作了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">13:09:53 CST success: [roy-qtc6]<br>13:09:53 CST success: [roy-300]<br>13:09:53 CST success: [roy-macbookair]<br>13:09:53 CST Pipeline[AddNodesPipeline] execute successfully<br>❯ kubectl get nodes<br>NAME             STATUS   ROLES                  AGE     VERSION<br>roy-300          Ready    worker                 2m41s   v1.22.12<br>roy-macbookair   Ready    worker                 23h     v1.22.12<br>roy-qtc6         Ready    control-plane,master   4d18h   v1.22.12<br></code></pre></td></tr></table></figure><p>安装出了问题也别急，<code>./kk delete cluster</code>解君愁。</p><h1 id="角色、权限等配置"><a href="#角色、权限等配置" class="headerlink" title="角色、权限等配置"></a>角色、权限等配置</h1><p>就像大多数成熟的管理系统一样，初始化安装之后会分配一个admin账户，然后再通过该账户创建一个业务账户，之后大多数操作都应该通过业务账户进行操作。</p><p>而这些概念、操作在每个云平台上略有不同，且不影响k8s的核心组件，同时又都是基本都能在Web UI进行点点点操作，所以本段略。</p><p>可以参考<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/create-workspace-and-project/">在kubesphere创建企业空间、项目、用户和平台角色</a></p><h1 id="外部访问"><a href="#外部访问" class="headerlink" title="外部访问"></a>外部访问</h1><p>在安装好Cluster之后，可以看到每个Node连接的IP地址是10开头的，这个明显是Kubernetes Cluster的IP地址， 不是外部可以访问的IP地址，因此需要一个网关来提供外部访问。</p><h2 id="启动网关"><a href="#启动网关" class="headerlink" title="启动网关"></a>启动网关</h2><p>网关是在项目中运行的 <a href="https://github.com/kubernetes/ingress-nginx">NGINX Ingress 控制器</a>。</p><p><a href="https://www.kubesphere.io/zh/docs/v3.3/pluggable-components/service-mesh/">在安装后启用服务网格</a></p><pre><code class="hljs">本段为KubeSphere的配置，其他云平台可能不同</code></pre><p>使用定制资源定义（CRD）里面的clusterconfiguration的ks-installer进行安装，看名字就知道是KubeSphere自己的，其他云平台没有。</p><h2 id="提供外部访问"><a href="#提供外部访问" class="headerlink" title="提供外部访问"></a>提供外部访问</h2><p><a href="https://www.kubesphere.io/zh/docs/v3.3/cluster-administration/cluster-settings/cluster-gateway/">设置集群网关</a><br>访问模式设置为 NodePort，选择确定之后，集群网关详情里面会出现一个和宿主机网段相同的局域网网关IP地址（在我这里是192开头的），这个是可以访问的。</p><p><a href="https://www.kubesphere.io/zh/docs/v3.3/multicluster-management/enable-multicluster/retrieve-kubeconfig/#%E8%8E%B7%E5%8F%96-kubeconfig">通过使用 kubeconfig 文件配置访问集群</a><br>除了上面链接中的方法外，还可以在KubeSphere UI右下角的工具箱图标上悬停，然后在弹出菜单中选择 kubeconfig，点击右上角的下载按钮，就可以直接下载连接K8s的kubeconfig.yaml。</p><p>特别注意的是需要把Cluster里面的server IP替换为局域网的IP</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">cluster:</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://10.233.0.1:443</span>  <span class="hljs-comment"># 替换为集群网关详情里面和宿主机网段相同的局域网网关IP地址</span><br></code></pre></td></tr></table></figure><h1 id="KubeSphere-DevOps-系统"><a href="#KubeSphere-DevOps-系统" class="headerlink" title="KubeSphere DevOps 系统"></a>KubeSphere DevOps 系统</h1><pre><code class="hljs">本段为KubeSphere的配置，其他云平台可能不同，步骤在[KubeSphere DevOps 系统](https://kubesphere.io/zh/docs/v3.3/pluggable-components/devops/)</code></pre><p>KubeSphere全家桶的DevOps 系统基于 Jenkins 的 KubeSphere DevOps 系统是专为 Kubernetes 中的 CI&#x2F;CD 工作流设计的，它提供了一站式的解决方案，帮助开发和运维团队用非常简单的方式构建、测试和发布应用到 Kubernetes。(得了，感觉以前的工作又是造轮子了，这叫深度业务定制开发！)</p><blockquote><p>:warning: <strong>整个集群内存最好25Gi以上</strong>: 我一开始安装的时候就遇到了各种卡住且没有提示的问题，其实就是内存不够，但是增加内存是需要硬件成本的，排查的时候花了很多的精力和时间。</p></blockquote><h2 id="Troubleshooting-1"><a href="#Troubleshooting-1" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>在之前工作中用过实体机上的Jenkins，也用过k8s节点中的Jenkins，但从来没用过全家桶的Jenkins，因此本段就算安装不上，也完全不影响使用。</p><h3 id="安装一直卡住，没有任何提示与报错"><a href="#安装一直卡住，没有任何提示与报错" class="headerlink" title="安装一直卡住，没有任何提示与报错"></a>安装一直卡住，没有任何提示与报错</h3><p>很自然去查看pod状况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get pod -n kubesphere-devops-system<br>devops-jenkins-c8b495c5-4hqwf        0/1     Pending     0          19h<br><br>❯ kubectl describe pod devops-jenkins-c8b495c5-4hqwf -n kubesphere-devops-system<br>...<br>Containers:<br>  devops-jenkins:<br>...<br>    Requests:<br>      cpu:      2<br>      memory:   2Gi<br>Events:<br>  Type     Reason            Age    From               Message<br>  ----     ------            ----   ----               -------<br>  Warning  FailedScheduling  69m    default-scheduler  0/1 nodes are available: 1 node(s) had taint &#123;node.kubernetes.io/memory-pressure: &#125;, that the pod didn<span class="hljs-string">&#x27;t tolerate.</span><br></code></pre></td></tr></table></figure><p>（这里有时Events里面会是空的，就只能靠其他信息推测了）</p><p>但是很神奇的是查看node本身并没有添加任何污点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get nodes -o json | jq <span class="hljs-string">&#x27;.items[].spec.taints&#x27;</span><br>null<br></code></pre></td></tr></table></figure><p>然后再仔细审视<code>describe pod devops-jenkins</code>pod的描述，报错是内存pressure，多半是内存不足，然后惊讶地发现需要2Gi的内存，而我的传家宝MacBook Air只剩下可怜的不到1Gi，由于这是物理资源的不足，无法弥补，要么放弃体验KubeSphere DevOps全家桶，要么只能自己在另一台物理机&#x2F;node上安装jenkins。</p><p>一想到某人那种32Gi的电脑沉迷召唤师峡谷，就想悄悄给装一个Ubuntu上去996.</p><p>（2天后更新： 结果把自己的神船刷Ubuntu了，然后去给朋友搬家捡了的PC）</p><p>整一些内存大的电脑添加到Cluster 成为Node就好了。</p><p>实测发现要装KubeSphere DevOps 系统最好还是保证整个集群内存有25Gi以上的容量，否则会出现各种问题，为此时隔十多年我又玩起了虚拟机，这里<strong>只推荐正统的VMware，VirtualBox</strong>这种，否则虚拟化的大坑欢迎您。</p><h1 id="Cluster-Uninstall"><a href="#Cluster-Uninstall" class="headerlink" title="Cluster Uninstall"></a>Cluster Uninstall</h1><p>当Cluster出现某些问题，且安装上面的排查依旧不能解决的时候，就使用重装大法，DevOps的其中一个特质就是无状态、重装方便，在应用部署上这是巨大的进步。</p><p>首先需要一个config-sample.yaml来配置集群的信息，比如Master &#x2F; Worker Node 的IP，账户等，如果没有的话，<code>./kk create config-sample.yaml</code>生成一下新的。</p><p>然后<code>./kk delete cluster -f config-sample.yaml</code></p><p>接着SSH到每一台Worker Node机器上，进行<a href="https://stackoverflow.com/questions/44698283/how-to-completely-uninstall-kubernetes">深度清理</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm reset<br><span class="hljs-built_in">sudo</span> apt-get purge kubeadm kubectl kubelet kubernetes-cni kube*   <br><span class="hljs-built_in">sudo</span> apt-get autoremove  <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf ~/.kube<br></code></pre></td></tr></table></figure><p>上面这个命令是把包都干掉了（而且实测不用重启机器就生效）</p><p>If you are clearing the cluster so that you can start again, then, in addition do the following to ensure my systems are in a state ready for kubeadm init again:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm reset -f<br><span class="hljs-built_in">rm</span> -rf /etc/cni /etc/kubernetes /var/lib/dockershim /var/lib/etcd /var/lib/kubelet /var/run/kubernetes ~/.kube/*<br>iptables -F &amp;&amp; iptables -X<br>iptables -t nat -F &amp;&amp; iptables -t nat -X<br>iptables -t raw -F &amp;&amp; iptables -t raw -X<br>iptables -t mangle -F &amp;&amp; iptables -t mangle -X<br>systemctl restart docker<br></code></pre></td></tr></table></figure><p>这个时候就算清理干净了，最后再回到Master Node机器上，执行<code>./kk create cluster -f config-sample.yaml</code>，等待一段时间后，集群就重新安装好了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本文历时半个月，从4月13号被干掉，休息半个月，5月1号开始搭环境，经过了半个月走走停停，不断地试错，查资料，写总结，才终于在5月20号地今天完成这个学习计划的开头 ————环境搭建。</p><p>这一个月里，有耍到接近昏迷，也有一天4个场面试的高强度，有点回到了快毕业那会的节奏。只是再也不像当初那么无助，迷茫而又没用行动力了。</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hard 4. Median of Two Sorted Arrays -- 第一道Hard，做了5年。</title>
    <link href="/2022/05/29/leetcode/4_hard%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/05/29/leetcode/4_hard%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我最重要的一道题，第一次遇到看题解也无法理解的题，想起了以前高中去竞赛划水的日子，想起了在大学划水地没有去竞赛的日子。</p><p>第一次看到这个题的时候，我还不知道做工程分前端和后端，我还可能只有170斤，我还看着Java代码觉得太丑陋看不懂；</p><p>后来小付快速的把这题理解并做出来了，我还是没有足够的行动力，后来就开始了一系列的迷茫的日子；</p><p>这么多年过去了，只有山东大哥的红轴Cherry键盘一直陪着我，他拿这键盘打Dota，考研；我拿这把键盘打Lol，假装考研；又在磨子桥的电脑城被我的老乡阵修理+魔改；然后在成都摸鱼，在深圳打字。</p><p>有很多变化了，又有很多没有变，不过看样子我的行动力确实螺旋上升了。</p><span id="more"></span><h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:</p><p>nums1 &#x3D; [1, 3]<br>nums2 &#x3D; [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 &#x3D; [1, 2]<br>nums2 &#x3D; [3, 4]</p><p>The median is (2 + 3)&#x2F;2 &#x3D; 2.5</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="保底算法"><a href="#保底算法" class="headerlink" title="保底算法"></a>保底算法</h2><p>先排序再找中位数，由于python的sort()使用的是快排，所以o(n)&#x3D;log(n)，不过揣摩出题人意图，肯定不是想考察这个知识点。</p><h2 id="分析类型"><a href="#分析类型" class="headerlink" title="分析类型"></a>分析类型</h2><p>分析之后不难得出，本题的目的是找出2个有规律的数组中的一个有特征的值，稍微思考之后能够得出可以用分治法；</p><p>原因为： 中位数实际上只与整个数组中位置最中间的两个数有关系，因此2个数组的共同中位数也只会与最多2数组中各取2个数（共计4个数）有关系，而其他部分都可以剪枝。</p><h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        nums1_small = nums2_small = <span class="hljs-number">0</span><br>        nums1_big = <span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span><br>        nums2_big = <span class="hljs-built_in">len</span>(nums2) - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span> nums1_big - nums1_small + nums2_big - nums2_small &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># TODO 一头一尾一个个删除</span><br><br>        <span class="hljs-comment"># 只剩下其中一个列表</span><br>        <span class="hljs-keyword">if</span> nums1_small &gt; nums1_big:<br>            <span class="hljs-keyword">return</span> (nums2[nums2_small] + nums2[nums2_big]) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums2_small &gt; nums2_big:<br>            <span class="hljs-keyword">return</span> (nums1[nums1_small] + nums1[nums1_big]) / <span class="hljs-number">2</span><br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">max</span>(nums1[nums1_small], nums2[nums2_small]) + <span class="hljs-built_in">min</span>(nums1[nums1_big], nums2[nums2_big])) / <span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>有了上述思路之后不难写出最初版本的伪代码：既找出分治原子，然后不断缩小问题规模；<br>体现在本题中就是：每次判断2数组两端4个数字，淘汰掉其中最大和最小的2数；然后当其中一个数组无法再淘汰数时</p><h2 id="分治原子有问题"><a href="#分治原子有问题" class="headerlink" title="分治原子有问题"></a>分治原子有问题</h2><p>跑了几个用例之后发现不正确，因为按照上述算法只有把其中一个数组中的数全部淘汰完了才是分治原子，这是不符合中位数定义的，因为每一个数组的最中间的2个数都是有成为“共同中位数”的可能的，因此分治原子条件应当是任意一个数字的长度小于2；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_mid</span>(<span class="hljs-params">nums</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                len_nums = <span class="hljs-built_in">len</span>(nums)<br>                left = (len_nums - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>                right = len_nums // <span class="hljs-number">2</span><br>                <span class="hljs-keyword">return</span> (nums[left] + nums[right]) / <span class="hljs-number">2</span><br><br>        len1 = <span class="hljs-built_in">len</span>(nums1)<br>        len2 = <span class="hljs-built_in">len</span>(nums2)<br>        <span class="hljs-keyword">while</span> len1 &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> len2 &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># TODO 一头一尾一个个删除</span><br>        <span class="hljs-keyword">if</span> len1 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> get_mid(nums2)<br>        <span class="hljs-keyword">if</span> len2 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> get_mid(nums1)<br>        <br>        <span class="hljs-comment"># TODO 解决其他分治原子问题</span><br><br>        <span class="hljs-keyword">return</span> get_mid(nums1)<br></code></pre></td></tr></table></figure><p>中间其实经过了长达一个星期的思考和尝试，在这里意义不大就不展开了，毕竟距离我第一次看这个题已经过去5年；</p><p>主要解决以下问题：</p><ol><li>摒弃中学时代的“下标处理数组模式”，都做了这么多年工程了，还是要明白可读性是远比”性能“重要的，且最后的时间表也看得出来并没有多少损耗；</li><li>优先处理特殊情况，这个从OJ到工程都是很重要的，这个都忘了那就没啥可说的了；</li><li>分治原子找错了，当其中任意一个数组只剩小于2个数的时候就可以结束分治进入决赛圈了；</li></ol><h2 id="分治原子的优化-O-n-的思辨"><a href="#分治原子的优化-O-n-的思辨" class="headerlink" title="分治原子的优化 &amp; O(n)的思辨"></a>分治原子的优化 &amp; O(n)的思辨</h2><p>在本来的做法中，进入决赛圈后，我是拿其中小的那个数组中剩下的数去和大的数字的两边，中间各个数字进行比较；</p><p>为此还总结了3种情况： 包含在大的中，分离在大的外，与大的交叉，然后又根据这三种情况进一步的分类，试图找出通用的比较规则；</p><p>实际上非常的蠢，是属于自己给自己找麻烦，且实际上的刷题过程中，经常由于这种case过多的情况进行放弃。</p><p>在连续想了一个星期之后，突然发现，对于分治原子来说，最后这一步使用的方法是不会影响到整体的时间复杂度的，且做了这么多年工程，熟练使用轮子的意义远大于反复的抠这几个下标，于是果断使用先合并、排序再找中位数的方法；</p><p>且由于最后决赛圈的中位数说白了还是在小于4个数之间出现，因此这一步O(n)&#x3D;1；</p><p>实际上很多时候思维是会被自己局限的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TODO 解决其他分治原子问题 code</span><br>nums1.extend(nums2)<br>nums1.sort()<br><br><span class="hljs-keyword">return</span> get_mid(nums1)<br></code></pre></td></tr></table></figure><h2 id="分治策略的优化"><a href="#分治策略的优化" class="headerlink" title="分治策略的优化"></a>分治策略的优化</h2><p>跑几个case之后就会发现，实际上对一个数组来说，除了“中间”一点的位置可能产生中位数，其他部位其实都是炮灰；</p><p>再发现数组边上其实很多时候都是在重复淘汰同一边的数，在继续观察之后发现规律：</p><p>先比较两个数组的中位数，同时将2个数组平均分成两份，考虑一下，中位数只可能诞生在两个数组相对“中间”的位置，因此一次性淘汰掉2个数组的两边的部分；</p><p>最后再注意一下边界取值等，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TODO 一头一尾一个个删除</span><br>len1 = <span class="hljs-built_in">len</span>(nums1)<br>len2 = <span class="hljs-built_in">len</span>(nums2)<br><span class="hljs-keyword">while</span> len1 &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> len2 &gt; <span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums1) == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums2) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">break</span><br><br>    mid_1 = get_mid(nums1)<br>    mid_2 = get_mid(nums2)<br>    <span class="hljs-keyword">if</span> mid_1 == mid_2:<br>        <span class="hljs-keyword">return</span> mid_1<br>    <span class="hljs-keyword">elif</span> mid_1 &lt; mid_2:  <span class="hljs-comment"># 砍掉nums1小的和nums2大的部分</span><br>        cut = <span class="hljs-built_in">min</span>((<span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>, (<span class="hljs-built_in">len</span>(nums2) - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>)<br>        nums1 = nums1[cut:]<br>        nums2 = nums2[:len2 - cut]<br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 砍掉nums1大的和nums2小的部分</span><br>        cut = <span class="hljs-built_in">min</span>((<span class="hljs-built_in">len</span>(nums2) - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>, (<span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>)<br>        nums1 = nums1[:len1 - cut]<br>        nums2 = nums2[cut:]<br>    len1 = <span class="hljs-built_in">len</span>(nums1)<br>    len2 = <span class="hljs-built_in">len</span>(nums2)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从二叉树遍历到yield</title>
    <link href="/2022/05/29/leetcode/python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2022/05/29/leetcode/python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="yield的作用"><a href="#yield的作用" class="headerlink" title="yield的作用"></a>yield的作用</h1><p>首先yield就是return，不要想多了，所以搭配<code>yield from func()</code>能够递归，就是这么简单；</p><p>只是说普通的函数返回的是一个value或者obj，而yield返回的是一个生成器对象。</p><h2 id="生成器的定义-同迭代器的区别"><a href="#生成器的定义-同迭代器的区别" class="headerlink" title="生成器的定义&amp;同迭代器的区别"></a>生成器的定义&amp;同迭代器的区别</h2><p>在python中实现了__iter__和__next__方法，可以迭代操作的对象就叫迭代器；<br>构建迭代器的时候，并不一次性加载所有元素到内存，只有调用next方法的时候才会<strong>返回</strong>需要的该元素；</p><span id="more"></span><p>生成器就是一种迭代器，由生成器函数返回；<br>生成器函数就是上文中的 return -&gt; yield的函数；  </p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>学以致用，看文档的时候自然说：都懂，都懂，结果自己不仅写不来还看不懂。<br>尤其是再遇到几个yield并排就不会了？</p><h2 id="当一个生成器函数中多个yield并排"><a href="#当一个生成器函数中多个yield并排" class="headerlink" title="当一个生成器函数中多个yield并排"></a>当一个生成器函数中多个yield并排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():  <span class="hljs-comment"># 普通函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():  <span class="hljs-comment"># 生成器函数</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 遍历一个生成器</span><br>it = gen()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        sys.exit()<br></code></pre></td></tr></table></figure><p>要遍历一个生成器，自然需要调用next方法到报错为止，实际上行为和遍历序列的时候下标越界同理，只是现代编译器做好了没意识到而已。  </p><blockquote><p>普通函数func调用：<br><code>print(func())  # 1</code><br><code>print(func())  # 1</code></p></blockquote><blockquote><p>生成器函数调用：<br><code>it = gen();  # 获得一个生成器</code><br><code>print(next(it))  # 1</code><br><code>print(next(it))  # 2</code>  </p></blockquote><h2 id="为啥要用生成器"><a href="#为啥要用生成器" class="headerlink" title="为啥要用生成器"></a>为啥要用生成器</h2><p>从上文中可以看到生成器函数一个巨大的优势就是函数写出来是分块的，可以直接剪掉很多的选择分支，让代码更加的整洁接近算法描述。<br>尤其是当需要递归的时候，使用yield的代码写出来简直就像是伪代码，曾一度让我无法理解其中的逻辑分支和递归基是如何运行的。</p><p>比如使用普通函数实现中序遍历一个BST的伪代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">global_res = []<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):  <span class="hljs-comment"># 定义一个二叉树</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-variable language_">self</span>.val = val<br>        <span class="hljs-variable language_">self</span>.left = left<br>        <span class="hljs-variable language_">self</span>.right = right<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 递归基</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    in_order_visit(node.left)<br>    global_res.append(node.value)<br>    in_order_visit(node.right)<br><br>in_order_visit(root)  <span class="hljs-comment"># root为需要遍历的BST的根节点</span><br><span class="hljs-built_in">print</span>(global_res)<br></code></pre></td></tr></table></figure><h3 id="递归参数只能是对象本身，遍历出来的值无法收集"><a href="#递归参数只能是对象本身，遍历出来的值无法收集" class="headerlink" title="递归参数只能是对象本身，遍历出来的值无法收集"></a>递归参数只能是对象本身，遍历出来的值无法收集</h3><p>可以明显的看得出来，遍历函数本身在递归的过程中<strong>参数只能是node or None</strong>，同时<strong>node &#x3D; None作为递归基</strong>；<br>那么问题来了，我<strong>遍历出来的值</strong>如何返回给上层呢？<br>我当时的函数设计的无比复杂，进入函数的时候先进行一个<strong>逻辑判断</strong>，再选择进入node.left还是返回node.value，因此一个函数就可能<strong>接受2种数据结构</strong>，<br>再根据自己的下面的调用结果判断是该继续往下递归还是往上return。</p><h3 id="需要的值放到递归参数中会导致逻辑十分混乱"><a href="#需要的值放到递归参数中会导致逻辑十分混乱" class="headerlink" title="需要的值放到递归参数中会导致逻辑十分混乱"></a>需要的值放到递归参数中会导致逻辑十分混乱</h3><p>代码无比丑陋，逻辑无比复杂。<br>不得已，只得引入<strong>全局变量</strong>（不引入也可以，可以让遍历函数返回一个元组(node, node.value: list[int])，但本质没变，就是把列表当成指针来用，还是全局，这不pythonic）<br>让遍历函数只专心访问node，我用一个全局变量来储存访问结果（也就是网上教材都只让你print出来的操作）<br>问题是全局变量应该少用，这是破坏结构性的，不管是封装成对象还是闭包还是什么玩意儿；<br>或者不用递归，用循环 + 堆栈来访问这个树，这与本文无关。</p><h3 id="必须将所有节点全部访问到内存"><a href="#必须将所有节点全部访问到内存" class="headerlink" title="必须将所有节点全部访问到内存"></a>必须将所有节点全部访问到内存</h3><p>迭代器可以每次调回的时候再到下一个节点，在有些情况（比如求前n个数），就不用像普通函数这样需要先遍历（排序）整个树，然后再截取需求的部分。</p><h3 id="试图yield实现递归"><a href="#试图yield实现递归" class="headerlink" title="试图yield实现递归"></a>试图yield实现递归</h3><p>使用生成器函数遍历一个BST的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit_gen</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">yield</span> visit_bst(node.left)<br>    <span class="hljs-keyword">yield</span> node.val<br>    <span class="hljs-keyword">yield</span> visit_bst(node.right)<br><br>it = visit_bst(root_node)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br></code></pre></td></tr></table></figure><p>结果非常意外<code>&lt;generator object visit_bst at &#39;addr in mem&#39;&gt;</code><br>为什么呢？<br>其实很简单，因为yield是懒狗，它只会返回一个it（迭代器&#x2F;生成器)，还记得之前的“生成器函数调用”的方法么。<br>每次需要先调用生成器函数，得到一个it，相当于把无产阶级请过来了<code>it = gen()</code><br>然后在调用这个迭代器，才能调用，相当于任务分配下去了<code>print(it)</code></p><p>因此如果yeild接自己想递归的话，第一次下去的时候，就会直接返回一个visit_bst(node.left)，还记得吗，这是一个生成器函数，现在调用它自然只会得到一个迭代器，还需要在外面像“遍历一个生成器”一样不断地用next去调用才能启动。</p><h3 id="yield-from-return-递归"><a href="#yield-from-return-递归" class="headerlink" title="yield from &#x3D; return -&gt; 递归"></a>yield from &#x3D; return -&gt; 递归</h3><p>python好就好在他有足够多的语法糖，在本文中只要粗暴的记得以下等价关系就行<br>yield obj &#x3D; yield from func() &#x3D; return obj&#x2F;func()  # 递归过程<br>相当于yield from就是先调用这个func得到一个it，然后马上就调用这个it一次，因此就得到了递归；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit_gen</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> visit_bst(node.left)<br>    <span class="hljs-keyword">yield</span> node.val<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> visit_bst(node.right)<br><br>it = visit_bst(root_node)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br></code></pre></td></tr></table></figure><h3 id="并排yield-递归表达式"><a href="#并排yield-递归表达式" class="headerlink" title="并排yield -&gt; 递归表达式"></a>并排yield -&gt; 递归表达式</h3><h1 id="TODO-有空再写吧。"><a href="#TODO-有空再写吧。" class="headerlink" title="TODO 有空再写吧。"></a>TODO 有空再写吧。</h1>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
