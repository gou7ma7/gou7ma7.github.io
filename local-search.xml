<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <link href="/2025/08/09/leetcode/3.%20Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <url>/2025/08/09/leetcode/3.%20Longest%20Substring%20Without%20Repeating%20Characters/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/gou7ma7/leetcode/blob/master/3.%20Longest%20Substring%20Without%20Repeating%20Characters.py">https://github.com/gou7ma7/leetcode/blob/master/3.%20Longest%20Substring%20Without%20Repeating%20Characters.py</a></p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>Very funny, I just unexpectlly find out that it is 3rd of Leetcode, but I only remembered that it should be resolved by sliding window.</p><h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><p>A <strong>sliding window</strong> is not merely defined by two numerical index: the left offset and the right offset.</p><h1 id="Intuitive-version"><a href="#Intuitive-version" class="headerlink" title="Intuitive version"></a>Intuitive version</h1><p>We init left and right index, and between string[left: right] slide is the windows, this is very intuitive.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">intuitive</span>(<span class="hljs-params">s</span>):<br>    len_s = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> len_s &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> len_s &lt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, s[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == s[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">2</span>, s<br>    left = right = <span class="hljs-number">0</span><br>    len_s = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    result_substring = <span class="hljs-string">&#x27;&#x27;</span><br>    max_len = <span class="hljs-number">1</span><br>    record_set = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">while</span> left &lt; len_s - <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> s[right] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> record_set:<br>            <span class="hljs-keyword">if</span> max_len &lt;= right + <span class="hljs-number">1</span> - left:<br>                result_substring = s[left: right+<span class="hljs-number">1</span>]<br>                max_len = right + <span class="hljs-number">1</span> - left<br>            <br>            record_set.add(s[right])<br>            <span class="hljs-keyword">if</span> right &lt; len_s:<br>                right += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            record_set.remove(s[left])<br>            left += <span class="hljs-number">1</span><br>        <br>        <br>    <span class="hljs-keyword">return</span> max_len, result_substring<br></code></pre></td></tr></table></figure><p>The coding process is so smoothly, it must be that I was too <strong>NERVOUS</strong> to coding a O(n^3) algorithm.</p><p>What A STUPID man!</p><p>The window slide only in a loop, move right and left should be in a same leveled loop! </p><p>That time I got a outter loop to move right, and another inner loop to move left, and what is more, maintain a s[now_left: now_right+1] to check whether it contains duplicate char each loop.</p><p>With above code, it seems that it should a Medium…</p><p>And with replacing record_set -&gt; record_dict, it IS O(n) now.</p><p>It’s over. All is lost.</p><h1 id="Slide-with-record"><a href="#Slide-with-record" class="headerlink" title="Slide with record"></a>Slide with record</h1><p>In above code, you can see that the set()&#x2F;dict() is always add a element and move the same one, and what is more, there are so many break when right &lt; len and now char not in <code>record_dict</code>, so we could use a dict to record index, and reassign it to means “Oh, now window contains repeated char, we should slide it to get a new window”.</p><p>But the time complex is same as intuitive version, just substract some branch, if nervious, just use initial version!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">slide_with_record</span>(<span class="hljs-params">s</span>):<br>    left = <span class="hljs-number">0</span><br>    max_right = <span class="hljs-number">0</span><br>    max_len = <span class="hljs-number">0</span><br>    record_dict = &#123;&#125;  <span class="hljs-comment"># Did you see that the above set is always remove and add a same char, so can I combine the too action?</span><br>    <span class="hljs-keyword">for</span> right, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>        <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> record_dict <span class="hljs-keyword">and</span> record_dict[char] &gt;= left:  <span class="hljs-comment"># now turn get repeat, so the len of windows won&#x27;t increase, only slide left</span><br>            <br>            left = record_dict[char] + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># slide the repeated char&#x27;s left to now + 1 to count window if next this repeated char appear again. (if appear is not the char, of cause ignore the char&#x27;s left index, it will count itself&#x27;s left index)</span><br>        record_dict[char] = right<br>        <span class="hljs-keyword">if</span> max_len &lt;= right - left + <span class="hljs-number">1</span>:<br>            max_len = right - left + <span class="hljs-number">1</span><br>            max_right = right<br><br>    <span class="hljs-keyword">return</span> max_len, s[max_right - max_len + <span class="hljs-number">1</span>: max_right + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hard</tag>
      
      <tag>Sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Life is a Game: Ditch the Tech Obsession</title>
    <link href="/2025/08/01/career/Life%20is%20a%20Game:%20Ditch%20the%20Tech%20Obsession/index/"/>
    <url>/2025/08/01/career/Life%20is%20a%20Game:%20Ditch%20the%20Tech%20Obsession/index/</url>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=114943256956471&bvid=BV1Ge8zztEiK&cid=31392662799&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px;"> </iframe>文化工作者一定要有文化<hr><p>这篇文章是针对 2025年 前半年的一个小小总结吧，因此不用生拽英文了。</p><p>也是我站在一个自诩的核心游戏玩家的角度 “技术” 在我职业发展规划的一些反思。</p><p>到百度也快半年了，在这个 M 序列 (Management Sequence) 也呆过了，能从一个更多的视角看待 “技术” 。</p><h1 id="游戏没有带娃硬核"><a href="#游戏没有带娃硬核" class="headerlink" title="游戏没有带娃硬核"></a>游戏没有带娃硬核</h1><h2 id="再难挂念"><a href="#再难挂念" class="headerlink" title="再难挂念"></a>再难挂念</h2><p>我一直认为游戏是对现实世界的一种片面的模拟，同时也是一种高度特性的学习。</p><p>或许是从其他地方得到的正反馈越来越多，现在从游戏中获得的快乐越来越少，同时可能由于见识的增长，很容易就看出当前游戏是对某个高度特性的知识体系（甚至不能叫体系，只能叫技能组合）的学习，因此很快就腻了。</p><h2 id="相识亚楠"><a href="#相识亚楠" class="headerlink" title="相识亚楠"></a>相识亚楠</h2><p>以前一段时间我曾以为我是魂系游戏的受众，后来发现自己只是喜欢玩《血源诅咒》罢了。</p><p>我一直好奇很多年以后我们小孩知道一切的开始是因为他的妈妈借 PS4 给他的爸爸玩《血源诅咒》的时候他会怎么想。</p><p>不过可能那个时候已经实现了真正的元宇宙了，app, 游戏, 现实的界限会模糊不清。</p><p>结婚之前我们一起玩了很多游戏，也时常一起和朋友们鏖战《英雄联盟》，感觉就像回到大学宿舍天天不上课那段时间，只是肯定不会像当时那样又空虚又迷茫。</p><h2 id="对两性关系的思考"><a href="#对两性关系的思考" class="headerlink" title="对两性关系的思考"></a>对两性关系的思考</h2><p>以前在知乎上看到： 情侣（或者其他）之间的亲密关系靠生产维系的要大大好于消费。</p><p>生完小孩之后我们就再也没有在一起打过游戏了。（最后一次是在怀孕期间医院一起玩的 《文明6》）</p><p>虽然我只负责在带娃方面打下手，但是依旧觉得这是一个非常硬核的游戏，我家的娃已经是 Easy mode， 非必要情况不会哭闹，而且反馈给得很足，能让我看到我发出的指令能有回应，绝大多数时候能给我极大的满足。</p><p>但是在处理像落地醒的时候还是非常折磨人的，一遍遍地尝试却不得要领的时候，耐心尽失脑袋发懵，总不自觉会回想起来“中学考试の怜悯” – 划重点啊划重点。</p><h2 id="合作，与游戏对比"><a href="#合作，与游戏对比" class="headerlink" title="合作，与游戏对比"></a>合作，与游戏对比</h2><p>费孝通先生在《乡土中国》中描述的中国特有的“爱情”发生在同性之间，夫妻之间只存在合作。</p><p>我想起小时候在镇上，确实总是只看到三五成群的爷子们觥筹交错。</p><p>我又再想，会不会很多非硬核游戏玩家的“情侣”，在一开始就没有共事过？所谓的“培养感情”只是不断使用同样类型的消费品来给两人贴上共同的标签，就像《花束般的恋爱》中所描述的那样。</p><p>或许我们最近没有再一起玩游戏，是因为一起在带娃，反馈、挑战、探索和精力消耗都已经足够了。</p><p>换句话说，不是游戏不好玩了，是它的生态位被占据了。</p><h1 id="技术落地"><a href="#技术落地" class="headerlink" title="技术落地"></a>技术落地</h1><p>燕国的地图还是有点长哈，绕了这么大一圈，刚刚讲完了标题中前半部分，现在到后半部分了。</p><h2 id="游戏与技术"><a href="#游戏与技术" class="headerlink" title="游戏与技术"></a>游戏与技术</h2><p>回过头来我很早之前就非常支持《明末》，毕竟是家乡产品。我有很多的感慨，但是看了 STN 之后觉得有他的这个点评就已经够了，有评论道：“分析出我们潜意识意识到的东西然后帮我们意识到表达出来”</p><p>作为野路子出身的程序员，我总是很羡慕好学校以毕业就能进大厂，然后持续在一个领域里不断精进的人。</p><p>正如评价一个游戏的核心指标一定是好不好玩，一个结合时代背景落地创造价值的技术始终是奇技淫巧的自我满足。</p><p>其实很多时候感觉“技术追求”都成了不安现状的遮羞布，但是又不能真的静下心来踏实钻研一个领域的技术，生怕到时候市场不认可或者不能“货与帝王家”。</p><h2 id="执念"><a href="#执念" class="headerlink" title="执念"></a>执念</h2><p>最近看到知乎上有句话： 我们都只是在时间长河中刻舟求剑的可怜人罢了。</p><p>有些人或因主观、客观的原因，被困在“凡是”，但总是有人顺应时代后大权在握，言出法随之后才有资格提出显然的“猫论”。</p><p>个人觉得很多时候所谓的“执念”还是能力和期望不匹配的外在表现。</p><p>比起始终害怕点错工作技能树的技能点，打游戏又不去计较完全算作消耗资源又不会产生收益的“&#x2F;dev&#x2F;null技能点”了。</p><p>学新技术的时候各种怕投入产出比，打起来游戏就是赢一把就睡。</p><h2 id="未来的路"><a href="#未来的路" class="headerlink" title="未来的路"></a>未来的路</h2><p>絮絮叨叨写了很多了，感觉现在想要写出没有语病的句子还挺困难的，从读书时候就开始写总结，定目标然后抛诸脑后。</p><p>好在2025年这一年终于做到了成年以后就一直想做的减肥，减了 30斤，还有 30斤。</p><p>从小就想加入世界知名的公司，不过自问并没有一直持续做什么一步一个脚印的努力，都是在随波逐流。</p><p>之前错过了很多机会，现在路到了脚下，就看怎么走了。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mid-2025: Struggling with AI</title>
    <link href="/2025/07/15/ai/mid_2025_struggle_with_ai/index/"/>
    <url>/2025/07/15/ai/mid_2025_struggle_with_ai/index/</url>
    
    <content type="html"><![CDATA[<blockquote><p>After intensive AI chats, I’ve stopped writing English blogs. The interactive grammar corrections during our conversations prove that dialogue-based learning trumps one-way content creation.<br>高强度 chat with AI 后发现没必要坚持写英文博客了，因为和 AI 用英文对话后，人家会用标准的语法重复整理一遍我的问题，有交互的学习比单方面的输出效果好多了。</p></blockquote><h1 id="现在时"><a href="#现在时" class="headerlink" title="现在时"></a>现在时</h1><p>现在是 2025年的7月， 号称当前最强代码大模型的 Claude 4 Opus 也已经上线了一个月，而我也高强度使用了两个月百度更早发布的 ERINE-4.5-Turbo-128K-Preview。</p><h1 id="Claude-4-Opus"><a href="#Claude-4-Opus" class="headerlink" title="Claude 4 Opus"></a>Claude 4 Opus</h1><p>Claude 4 Opus 必须开启不计成本的 MAX Mode 才能使用，因此我只能用在新的小项目中，除非公司报销，但是众所周知我现在的公司是有相关自研的，因此报销是更不可能报销的。</p><h2 id="震撼"><a href="#震撼" class="headerlink" title="震撼"></a>震撼</h2><h3 id="去年半自动"><a href="#去年半自动" class="headerlink" title="去年半自动"></a>去年半自动</h3><p>在去年2024年底的时候，一次我有个需要在24h做一个前后端 + LLM chat 的任务，当时肯定是没有 DeepSeek， 用的哪个模型我已经记不得了，但是清楚的记得我是没有做完的，从零开始生成的代码总有点小问题，然后上去一调试半个小时一个小时就没有，整个只能叫脚手架半自动生成工具。</p><h3 id="当前全自动"><a href="#当前全自动" class="headerlink" title="当前全自动"></a>当前全自动</h3><p>但是在 2025年中 的时候，Claude 4 很猛了，我试了一下 “失业程序员副业开发做应用三件套”：记账、todo list和番茄时钟的代码生成，不算思考和填写代码的时间，已经达到了分钟级，本来我还抱着还要亲自上去改的刻板印象，结果前后端代码是直接可以运行的！</p><p>这可以说是很震撼了，毕竟不是演示视频中那种小玩具，我看到生成出来的代码规模和架构已经可以当成完整的商业项目的 demo 了，这可是传统需要一个新手学习半年甚至更久的时间，只有自己亲眼看到才会有这种感觉。</p><p>期间只出现了一个跨域问题，而且都没有我去排查，直接就 fix 了，不禁逼着我想起当年学习的时候花了很多时间才能梳理相关的问题。</p><h2 id="怯魅"><a href="#怯魅" class="headerlink" title="怯魅"></a>怯魅</h2><h3 id="通用知识集"><a href="#通用知识集" class="headerlink" title="通用知识集"></a>通用知识集</h3><p>但是话又说回来，AI 无法写出使用者和普遍知识并集以上水平的代码。</p><p>“失业程序员副业开发做应用三件套”这种设计已然是和 “外包公司商业代码模版” 一样成熟的套路。</p><h3 id="特定领域"><a href="#特定领域" class="headerlink" title="特定领域"></a>特定领域</h3><h4 id="需求与-prompt"><a href="#需求与-prompt" class="headerlink" title="需求与 prompt"></a>需求与 prompt</h4><p>昨晚我让它生成我的一个<strong>需求</strong>： 在性能低下无法联网的电子书上生成一个 .js 的浏览器插件脚本，实现离线的词典<strong>划词翻译</strong>，对标欧路词典。</p><p>我尝试过这种<strong>不含技术细节，只描述</strong>的 prompt， 也试过 step by step 的指<strong>定技术栈甚至把离线词典文件都预先下载</strong>好了，让他用 js 解析的 prompt，但是很遗憾，这种小众需求它连理解都有非常大的困难。</p><h4 id="分析与优化"><a href="#分析与优化" class="headerlink" title="分析与优化"></a>分析与优化</h4><p>在需求上，因为我常年从事的 web backend 相关开发，没有浏览器插件相关的开发经验，我特别好奇的是假如我把 好几个M 大小的文件打包或者说当成静态资源放到某个路径，浏览器是否或者说应该如何读取；</p><p>此外我还一直在问它，我这个需求是否有其他的实现方式，希望他能去帮我搜索一下；</p><p>最后我还亲自找了好几个 GitHub 上已经实现了的 js 或者 python 的离线划词或者词典工程，就让它照着参考如何解析词典文件。</p><h4 id="斗智斗勇"><a href="#斗智斗勇" class="headerlink" title="斗智斗勇"></a>斗智斗勇</h4><p>但是以上前2点直接装死，不管我怎么问它都是在车轱辘话，我是不知道是训练模型的时候对我这种落后时代的离线小众需求不敏感，还是因为网上没有那么多现成的相应的实现导致它避重就轻，我个人是觉得我已经拆解描述清楚了，但是它就一直再演我，消极罢工。</p><p>对于第三点就更摸鱼了，即使我提供了参照的情况并且加了 “please check the download dictionary file, storge and cache complete and usable for js” 等等<strong>一大堆换着花样哄它的 prompt</strong>，并且也在一直强调和表述我的应用场景，我一直需要离线的。</p><p>最后它回馈我的描述词里面是清晰了写明了我的每一个需求点的，但是我最后看它生成出来的代码，里面还是有大量的 http 外部的请求；</p><p>于此同时，还会不厌其烦的自己去生成一个 all English to Chinese dictionary，根本看不到去 parse file 的代码片段。</p><p>斗智斗勇了一个晚上，我发现我的电纸书能装欧路词典，并且它会自动装浏览器划词翻译插件，只是不能用全局屏幕取词罢了。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>至少在 2025年总 我的感受是： 当前的 AI 能干掉很多通用领域的新手们了，但是资料少的特定领域还是只能当一个高级搜索引擎。</p><h1 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h1><p>todo</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Guided Rereading - Python Cookbook 3rd Edition</title>
    <link href="/2025/05/25/book/Python_Cookbook_3rd_Edition/"/>
    <url>/2025/05/25/book/Python_Cookbook_3rd_Edition/</url>
    
    <content type="html"><![CDATA[<!-- more --> <p>If I had to parse Kant pre-AI, but post-GPT still can’t comprehend, isn’t that like bringing a quantum computer to an abacus convention?<br><img src="/2025/05/25/book/Python_Cookbook_3rd_Edition/A_Futile_Arrival.png" alt="AI没来的时候跪着看这些书， AI来了还看不懂，那AI不是白来了吗？"></p><p>When AI cometh, the binary dawn shall brighten our skies!<br><img src="/2025/05/25/book/Python_Cookbook_3rd_Edition/With_AI's_Arrival.png.png" alt="AI来了，青天就有了"></p><h1 id="CHAPTER-1-Data-Structures-and-Algorithms"><a href="#CHAPTER-1-Data-Structures-and-Algorithms" class="headerlink" title="CHAPTER 1. Data Structures and Algorithms"></a>CHAPTER 1. Data Structures and Algorithms</h1><h2 id="1-2-Unpacking-Elements-from-Iterables-of-Arbitrary-Length"><a href="#1-2-Unpacking-Elements-from-Iterables-of-Arbitrary-Length" class="headerlink" title="1.2. Unpacking Elements from Iterables of Arbitrary Length"></a>1.2. Unpacking Elements from Iterables of Arbitrary Length</h2><h3 id="star-unpacking"><a href="#star-unpacking" class="headerlink" title="star unpacking"></a>star unpacking</h3><p>完整代码示例可参考 GitHub 仓库：<a href="https://github.com/gou7ma7/ai-guided-book-code/blob/main/Python_Cookbook_3rd_Edition/CHAPTER%201.Data%20Structures%20and%20Algorithms/star_unpacking_and_yield.py">star_unpacking_and_yield.py</a></p><p>星号解压语法中，一个赋值语句只能出现一次*，想来也是，不然就成了指代不明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">record = (<span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;dave@example.com&#x27;</span>, <span class="hljs-string">&#x27;773-555-1212&#x27;</span>, <span class="hljs-string">&#x27;847-555-1212&#x27;</span>)<br>name, email, *phone_numbers = record<br><span class="hljs-built_in">print</span>(phone_numbers)  <span class="hljs-comment"># [&#x27;773-555-1212&#x27;, &#x27;847-555-1212&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="1-3-Keeping-the-Last-N-Items"><a href="#1-3-Keeping-the-Last-N-Items" class="headerlink" title="1.3. Keeping the Last N Items"></a>1.3. Keeping the Last N Items</h2><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>完整代码示例可参考 GitHub 仓库： <a href="https://github.com/gou7ma7/ai-guided-book-code/blob/main/Python_Cookbook_3rd_Edition/CHAPTER%201.Data%20Structures%20and%20Algorithms/star_unpacking_and_yield.py#L78">star_unpacking_and_yield.py</a></p><p><a href="https://www.bilibili.com/video/BV1u5411R7C3">https://www.bilibili.com/video/BV1u5411R7C3</a></p><ol><li>实现了 <code>__iter__</code> 方法的类，就叫做可迭代对象；</li><li>又加上实现了 <code>__next__</code> 方法的类，就叫做迭代器；</li><li>yiled 相当于是上述两个方法的语法糖，yield 表达式分割的代码块，分割的后面执行的部分就相当于是 next，而整个含有 yiled 的函数（此时变成生成器函数）就相当于 iter， 同时这个函数会返回一个迭代器对象。</li></ol><p>yield 就是一个表达式，和 3 + 2 效果相同，是幂等的，在内部定义时候，有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">only_yield_on_right</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;will touch 1st yield&#x27;</span>)       <span class="hljs-string">&#x27;&#x27;&#x27;part 1&#x27;&#x27;&#x27;</span><br><br>    received = <span class="hljs-keyword">yield</span>  <span class="hljs-comment"># first yield but not send value, may be received will be None</span><br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received 1st: <span class="hljs-subst">&#123;received&#125;</span>&quot;</span>)  <span class="hljs-string">&#x27;&#x27;&#x27;part 2&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">only_yield_on_right</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;will touch 1st yield&#x27;</span>)       <span class="hljs-string">&#x27;&#x27;&#x27;part 1&#x27;&#x27;&#x27;</span><br>    <br>    <span class="hljs-keyword">yield</span>  <span class="hljs-comment"># first yield but not send value, may be received will be None</span><br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received 1st: <span class="hljs-subst">&#123;received&#125;</span>&quot;</span>)  <span class="hljs-string">&#x27;&#x27;&#x27;part 2&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>作用是完全相同的。</p><p>同样的 在外部调用的时候，gen.send(None) 作用完全等同 next(gen) （在不涉及传递值，仅仅从语法“语句”角度）</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Archived Read Books</title>
    <link href="/2025/04/24/career/Archived%20Read%20Books/"/>
    <url>/2025/04/24/career/Archived%20Read%20Books/</url>
    
    <content type="html"><![CDATA[<p>Flask Web开发 (第2版)<br>世界是部金融史<br>update: 2025年05月</p><span id="more"></span><h1 id="技术书籍"><a href="#技术书籍" class="headerlink" title="技术书籍"></a>技术书籍</h1><h2 id="AI相关"><a href="#AI相关" class="headerlink" title="AI相关"></a>AI相关</h2><h3 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h3><table><thead><tr><th>书籍名称</th><th>阅读时间</th><th>简评</th></tr></thead><tbody><tr><td>Flask Web开发 (第2版)</td><td>2025.05.21</td><td>水平相当之高，可以作为 Python 学习完语法之后的第二本书，深入浅出的手把手告诉你，学了 Python 能做什么。而且比起国内常见的四处摘抄的读书笔记流书籍，本书循序渐进没有一个地方跳跃。从业8年后回看此书，依旧收获颇丰，每个入门需要的地方都涵盖到了。认真学完（做完）本书真的可以有资格成为一名入门 web 软件开发工程师，但是真的很遗憾，只有当我有了这么多年从业经验，我才能有深刻的体会，尤其是 AI时代，好书常有而专注力不常有。</td></tr><tr><td>大模型应用开发极简入门</td><td>2025.04.13</td><td>没太大用处，还不如B站上看点视频</td></tr></tbody></table><h1 id="非技术书籍"><a href="#非技术书籍" class="headerlink" title="非技术书籍"></a>非技术书籍</h1><h2 id="社科"><a href="#社科" class="headerlink" title="社科"></a>社科</h2><h3 id="经济学"><a href="#经济学" class="headerlink" title="经济学"></a>经济学</h3><table><thead><tr><th>书籍名称</th><th>阅读时间</th><th>简评</th></tr></thead><tbody><tr><td>聊聊中国社会现状-大江宁静</td><td>2025.08.02</td><td>1. 体制内网友的分享，提供了很多新的观点；2. 看来不管什么时候都是“就业最艰难的一年”</td></tr><tr><td>风云百年——中国1908-2008</td><td>2025.07.02</td><td>太精彩了，而且作者居然自费更新了10年，真的是不管什么领域日积月累就会厚积薄发。（看完合集电子版后发现基本写到文革就停了，而且文中后面这些时代的部分比起同类文章阅读性有一些差距）</td></tr><tr><td>金钱统制 - 陈雨露</td><td></td><td></td></tr><tr><td>世界是部金融史 - 陈雨露</td><td>2025.05.29</td><td></td></tr><tr><td>中国是部金融史 - 陈雨露</td><td>2025.05.15</td><td>生动形象，言简意赅，像小说一样讲述平时未曾发现的道理，同时也印证了金钱没有其他流向就只能流向永远保值的土地，客观规律不体恤朝廷的难处。</td></tr></tbody></table><h2 id="网络帖子"><a href="#网络帖子" class="headerlink" title="网络帖子"></a>网络帖子</h2><h3 id="天涯神贴合集"><a href="#天涯神贴合集" class="headerlink" title="天涯神贴合集"></a>天涯神贴合集</h3><table><thead><tr><th>书籍名称</th><th>阅读时间</th><th>简评</th></tr></thead><tbody><tr><td>社会不教，精英不讲，坎儿还得自己过</td><td>2025.06.15</td><td>虽积累不如kk，但强调方向正确下的坚持实践，也是天涯合集中上乘之作，尤其是在我次困难的日子里读到，难得可贵。</td></tr><tr><td>解密社会中升官发财的经济学规律</td><td>2025.05.29</td><td>博主风趣幽默，语言生动，确实有一些道理。但和广为流传的成功学书籍有一样的特点-过分强调主观能动性，过分强调观念的决定性作用，忽视了必须要再经过自己的实践总结感悟，背诵观念只能是教条主义，这个是教不会的。知乎上“懂很多道理，过不好一生”正是对此的体现，对现阶段的我参考意义不大。这段时间不看贴子了，该回去背新概念了，毕竟种一个树最好的时候是十年前，其次是现在。</td></tr><tr><td>闲来8 一下自己幽暗的成长经历（口味很重，请慎入）- 风雪漫千山</td><td>2025.05.19</td><td>1.   天涯合集质量参差不齐，正一边删着无聊的帖子，就拜读到《人之大欲》作者的“自传”； 2.   感情真挚，文笔流畅，不愧为文艺圈子人；3.   很有《活着》的感觉，我想起了我身边一路走来很多的朋友；4.   当我成长时听到他们的身世、故事，感到十分的紧张、诧异和惶恐，可惜现已而立之年早已麻木不似当年赤子之心；5.   小时候一直不能理解为什么会有“狠心”、“冷漠”之人；6.   相比之下昨天的小作文帖子质量太差了，充斥着自己不愿意承认的“娇气”</td></tr><tr><td>他手机里有爱人 有秘密 有感情</td><td>2025.05.18</td><td>年龄大了见识也多了，觉得八卦故事本质上就是沉默成本，没啥新意。（和上文一样啊，经过移动互联网普及之后网友吃反转瓜锻炼太多，版本更新太快了）但前几天看到知乎上说到鲁路修 <a href="https://www.zhihu.com/question/47931678/answer/3627375562">https://www.zhihu.com/question/47931678/answer/3627375562</a> 之所以 “几部影视作品的台词契合度比较高，充分说明了一件事，zz的某些母题是相通的。” 我们生活在同一个世界，有人致力总结普遍真理，也有人迷信拾人牙慧，希望大家都能学有所成。</td></tr><tr><td>周公子大战易烨卿</td><td>2025.05.16</td><td>有挺多话想说的，有位后来的网友总结得好，经过20多年互联网的飞速发展，网友们的见识已经有了质的提升。回过头来看当时的帖子凸显着信息获取低效时代的稚嫩，而且当时上网非常麻烦能上网的论坛注册用户更是少之又少，顶着 ID 的都像武侠小说里面的侠客一样，既是互相对话，又像告知天下。时net娱乐方式又少，不像现在过招都是 KOL 拿着大喇叭制造舆论。</td></tr><tr><td>这个时代寒门再难出贵子</td><td>2025.04.28</td><td>文笔挺好的，读起来有冯骥才的感觉，作者应该是个善于观察总结学习的人。</td></tr><tr><td>kkndme_tianya</td><td>2025.04.26</td><td>训练数据 + 训练方法 + 模型 &#x3D; 见识，见识决定人生</td></tr></tbody></table><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    
    <tags>
      
      <tag>Read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025 Fitness Journey</title>
    <link href="/2025/04/24/career/2025_Fitness_Journey/"/>
    <url>/2025/04/24/career/2025_Fitness_Journey/</url>
    
    <content type="html"><![CDATA[<h1 id="Weight"><a href="#Weight" class="headerlink" title="Weight"></a>Weight</h1><h2 id="最近最佳"><a href="#最近最佳" class="headerlink" title="最近最佳"></a>最近最佳</h2><p>在 2025.02.27 时候，体重到达 199.7 斤，这是之前 2024 年末失业三个月极端少吃最大的成效。</p><p>少吃是饿不死人的，而且胃口会变小。保持热量差是减肥唯一且朴实无华的道理。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><input checked="" disabled="" type="checkbox"> 年中 稳定下 200 斤</li><li><input checked="" disabled="" type="checkbox"> 年底 尝试冲 190 斤 *1</li><li><input disabled="" type="checkbox"> 年底 稳定下 178 斤</li><li><input disabled="" type="checkbox"> 最终 不再胖 168 斤</li></ul><p>PS: 1.此数据为5月看情况不妙保守调整，结果3个月完成；</p><span id="more"></span><p>continue update</p><h2 id="190-斤"><a href="#190-斤" class="headerlink" title="190 斤"></a>190 斤</h2><p>2025.07.29 189.8斤 6.1%</p><p>减了一半，还剩一半。 到 178斤 （最后 10斤）的时候我会好好休息一下。</p><p>已经回答大学时候体重，之后减到的每一斤都是净赚。</p><p><img src="/2025/04/24/career/2025_Fitness_Journey/backto_teen.jpg" alt="weight_returns_to_youth"></p><p>在小红书上开贴记录了减肥的每个时间节点，下次再发就是下到 178斤 以后了。</p><p>同时解决了之前的一个疑惑： 我能做引体向上到底是因为力量变大了，还是减肥了。<br><img src="/2025/04/24/career/2025_Fitness_Journey/190.png" alt="down to 190 jin"></p><p>考虑到误差，我是在 8.3日 后观察到体重稳定徘徊在 190斤 一段时间，才在此记录是真的又进入另一个阶段。</p><p>不过比起当天几乎快下 26% 的体脂，现在还是挺高的，几乎和上一个阶段没有变化。</p><p>快了，所有的指标都在趋向正常，等我下一个阶段之后，就从最开始只有两个指标正常到只有两个指标不正常了，加油，行百里者半九十。</p><h2 id="195-斤"><a href="#195-斤" class="headerlink" title="195 斤"></a>195 斤</h2><p>2025.07.13 193.7斤 6.9%<br>回过头看，还真的是非常科学的一个月5斤，一周一斤。<br>最近不知道是秤还是称重姿势问题，同一时刻有时能偏差一斤。<br>实际上前几天就飘下过 195斤，但为了保险，今天才进行记录。</p><p>现在对甜食或者甜味有本能的抵制了，有时想到小时候吃完饭还用炒菜的红油泡饭吃，都忘了从什么时候逐渐开始改变观念的。</p><h2 id="200-斤"><a href="#200-斤" class="headerlink" title="200 斤"></a>200 斤</h2><p>2025.05.25 很巧啊，正好又是过了一个月，前几天心态还随着体重的尾巴反复起伏，在周五没胃口的限制饮食下，竟然一路高歌猛进，直接突破。<br><img src="/2025/04/24/career/2025_Fitness_Journey/200.PNG" alt="终于下200了"><br><img src="/2025/04/24/career/2025_Fitness_Journey/is_you.PNG" alt="这是你吗？"></p><h2 id="205-斤"><a href="#205-斤" class="headerlink" title="205 斤"></a>205 斤</h2><p>2025.04.24 近 30 天差不多是这个平均体重，这也是我开始适应张江工作后刚开始新的运动方式的起始体重。</p><p>同时，我在深圳一边锻炼一边狂吃也是这个体重，这4年里体重两度掉下 200 斤。</p><hr><h1 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h1><p>工作日中饭，晚饭时间各跑一小时，争取早上和晚上下班也能各跑半小时。  要是能按照这个节奏跑下来，不出半年我就强的可怕。</p><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul><li><p><input checked="" disabled="" type="checkbox"> 年中 - 2025.05.07：一口气连续慢跑10分钟 &#x2F; 1公里</p></li><li><p><input disabled="" type="checkbox"> 年底：一口气连续慢跑30分钟 &#x2F; 3公里</p></li></ul><p>continue update</p><h2 id="10min"><a href="#10min" class="headerlink" title="10min"></a>10min</h2><p>2025.05.07 带护膝，一口气（慢）跑了10分钟，7分钟才开始喘，无不适症状。<br>最近并没有完全坚持训练，且本次只是想稍微尝试，结果没想当进步如此巨大。</p><h2 id="5min"><a href="#5min" class="headerlink" title="&lt; 5min"></a>&lt; 5min</h2><p>2025.04.24 没带护膝，跑了不到 5 分钟，膝盖就开始痛。</p><hr><h1 id="Pull-Up"><a href="#Pull-Up" class="headerlink" title="Pull-Up"></a>Pull-Up</h1><p>2025.06.06 对我来说是个<strong>很重要的日子</strong>，本来只是心血来潮的想试一下，结果没想到做到了人生中第一个标准引体向上。</p><p>现在已经习惯性的少吃，也不会像以前一样恐惧饥饿。</p><p>晚上出去吃的，但已经很克制不会“加餐”，消灭未完的食物了。回家称到体重也没有上到200.</p><p>前段时间一直晚上都难以入睡，终于从前天开始能正常睡觉。</p><p>三十而立，明白了这么多的道理，经过了这些年的实践后，现在要开始<strong>真正的人生</strong>。</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=114636787551157&bvid=BV1NgTMzPEAG&cid=30355948788&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px;"> </iframe><blockquote><p>众所周知 Wide-Grip Pull-Up 宽距正手引体 是最标准的，我现在有以下3条不同力道的弹力带，用于辅助。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2~15磅&quot;</span> <span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;13~35磅&quot;</span> <span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;25~65磅&quot;</span> <span class="hljs-punctuation">&#125;</span> <br></code></pre></td></tr></table></figure><p>目标</p><ul><li><input checked="" disabled="" type="checkbox"> 年中 弹力带2 的辅助下做1个标准引体向上</li><li><input disabled="" type="checkbox"> 年底 弹力带1 的辅助下做1个标准引体向上</li><li><input disabled="" type="checkbox"> 预期 做1个标准引体向上<br><img src="/2025/04/24/career/2025_Fitness_Journey/Medium_Grip_Semi-Supinated_Grip_Pull-Up.png" alt="中距半正手"><br>2025.05.22 无意中发现自己已经能用一种折中的中距半正手做引体向上，期待解锁标准引体向上，这是我从来没有达到过的境地。</li></ul></blockquote><hr><h1 id="hiking‌"><a href="#hiking‌" class="headerlink" title="hiking‌"></a>hiking‌</h1><p>半个月一次</p><p>continue update</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Record</tag>
      
      <tag>Fitness</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建基于 RAG 的个人知识库</title>
    <link href="/2025/02/24/devops/setup_personal_rag_knowledge_base/"/>
    <url>/2025/02/24/devops/setup_personal_rag_knowledge_base/</url>
    
    <content type="html"><![CDATA[<h1 id="TODO-最近刚入职，太忙了，而且暂时也没钱买-5090D，同时公司的资源够我研究很久了"><a href="#TODO-最近刚入职，太忙了，而且暂时也没钱买-5090D，同时公司的资源够我研究很久了" class="headerlink" title="TODO  最近刚入职，太忙了，而且暂时也没钱买 5090D，同时公司的资源够我研究很久了"></a>TODO  最近刚入职，太忙了，而且暂时也没钱买 5090D，同时公司的资源够我研究很久了</h1><span id="more"></span><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>操作系统：Ubuntu 24.10</li><li>CPU: AMD Ryzen 9 5950X 16-Core Processor</li><li>内存：32GB</li><li>显卡：NVIDIA Corporation AD104 [GeForce RTX 4070] (rev a1)</li></ul><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=114063761739419&bvid=BV12tPveLEpr&cid=28570224111&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px;"> </iframe><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装-Ollama"><a href="#安装-Ollama" class="headerlink" title="安装 Ollama"></a>安装 Ollama</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://ollama.com/install.sh | sh<br></code></pre></td></tr></table></figure><h2 id="安装-ollama-chat"><a href="#安装-ollama-chat" class="headerlink" title="安装 ollama-chat"></a>安装 ollama-chat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AI时代 暨 找到工作的第一篇博客</title>
    <link href="/2025/02/24/career/1st_post_in_ai_era/"/>
    <url>/2025/02/24/career/1st_post_in_ai_era/</url>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>很有意思啊，经历了之前的焦虑后，开始恢复状态能正常开始学习了。</p><p>第三次被裁员了，前段时间心态起伏还是很大的，再加上家庭频出状况，很长一段时间不能集中精力学习，不过考虑到当时甚至连游戏都没有兴趣玩，现在也觉得没啥问题，哈哈。</p><p>之前删掉了啰嗦的充满“操作指南”、“操作记录”的博客，想着在 AI 时代没什么用，但是经过最近的学习，反而发现这些才是在 RAG 下宝贵的学习资料。</p><p>因为之前博客写完了，就像中学时代的“笔记”，“错题本”一样被动的放在那里，除非高度规律地规划定期回顾才能被用起来，而现在不同了，我需要迭代自己的 Workflow 了。</p><p><img src="/2025/02/24/career/1st_post_in_ai_era/screen.jpg" alt="做减法，不要再在桌子上摆很多个屏幕了"></p><h1 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h1><p>以前喋喋不休地在博客、抖音、B站、小红书上打卡，抱团，期望能坚持此前一直没能完成的减肥，但效果甚微。</p><p>大道至简，就和学习本身一样，没有每天落地的实践支持，都是空中楼阁，徒增笑耳。</p><!-- <img src="/2025/02/24/career/1st_post_in_ai_era/weight_loss_record.jpeg" class=""> --><p><img src="/2025/02/24/career/1st_post_in_ai_era/weight_loss_record.jpeg" alt="减肥数值记录"></p><h1 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h1><p>过去的一年里我成为了父亲，又失去了父亲，在这个社会角色定位中，我没有退路了。</p><p>小孩刚出生的时候太轻，妈妈操了太多的心。我当时暗下决心，希望我减肥下来的体重都能加到小孩上。</p><p>然后小孩体重稳步提升，达到了正常体重，反而是我却减得快多了，这是最近最值得开心的事情了。</p><p>迷茫的时候也想想，就像踏实减肥一样，积累到了才会看到成效，毕竟：</p><blockquote><p>没有数值，我只看到了努力和汗水。</p></blockquote><h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><p>AI 带来了很多改变啊，在首页里面已经有了足够的碎碎念了。</p><p>这段时间深度体验 + 部署之后，发现现阶段的 AI 在通识方面已经无敌，但在专业领域完全不能令我满意。</p><p>如果说以前的搜索引擎是纯粹只会认关键字的外行，现在的 AI 已经是过目不忘的学徒，能快速解决描述清晰且典型的问题，离指导工作者的行业专家还有一段距离。</p><p>这也是我现在更有动力更新博客的原因，期望能在 RAG 的帮助下打造成我的个人知识库。</p><h1 id="工作-（补于-2025年3月-找到工作后）"><a href="#工作-（补于-2025年3月-找到工作后）" class="headerlink" title="工作 （补于 2025年3月 找到工作后）"></a>工作 （补于 2025年3月 找到工作后）</h1><p>很神奇啊，找了三个月，终于找到工作了。</p><p>日子过得就像梦一样，从最开始知道要被辞退时候的惴惴不安，到后来排满了的疯狂面试，再到临近入职的不真实感，明明是一个季度内发生的，却感觉隔离地太彻底了。</p><p>期间心情相当大起大落，抛开各种变故的影响不谈，光是每次面试之后的抉择就觉得有够累人的，不过回想起来还是觉得每次样本训练就是一次成长。</p><p>前几天还能文思泉涌地持续码字，现在下班打开电脑，又回到上学时候那种提笔忘字的状态。</p><p>终于进入了世界一流知名度的公司，小时候幻想过无数次的场景，真的实现到自己身上的时候又全是不真实感。</p><p>虽然依旧是一颗螺丝钉，但是现在真的满脑子都是“我奋斗了18年才和你坐在一起喝咖啡”。</p><p>马上工作就快十年了，不知道其中浪费了多少年，总想做点有意义的事情，不要再混天过日了。</p><p>大概在高中的时候感悟出来了能<strong>看到努力的方向</strong>和<strong>持之以恒的努力</strong>是两项最大的天赋，有点晚了，</p><p>前30年也走了不少弯路，不过好在 AI时代 更多的信息差会被抹平，终于能赶上这班车了。</p><p>以下，贴上找工作期间（2024年12月～2025年3月）的自我介绍，仅做纪念。</p><hr><h3 id="Hi-there-👋-This-is-Roy-Lee-✨"><a href="#Hi-there-👋-This-is-Roy-Lee-✨" class="headerlink" title="Hi there 👋 This is Roy Lee! ✨"></a>Hi there 👋 This is Roy Lee! ✨</h3><p><a href="https://space.bilibili.com/776431"><img src="https://img.shields.io/badge/-Bilibili-00A1D6?style=flat&logo=bilibili&logoColor=white" alt="Bilibili"></a> <a href="https://www.linkedin.com/in/%E7%BA%A2%E7%9D%BF-%E6%9D%8E-a2a612157/"><img src="https://img.shields.io/badge/-LinkedIn-blue?style=flat&logo=Linkedin&logoColor=white" alt="Linkedin"></a> <a href="https://gou7ma7.github.io/"><img src="https://img.shields.io/badge/-Blog-red?style=flat&logo=Blog&logoColor=white" alt="Blog"></a></p><hr><h3 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h3><p>I’m Roy Lee (Li Hongrui in Chinese), a DevOps and Python backend engineer with experience in multiple NASDAQ-listed companies. My most recent role was at <strong>Agora (NASDAQ: API)</strong>, where I worked as a Developer Productivity Engineer.</p><p>After being laid off at the end of 2024, I’ve been actively seeking opportunities in <strong>DevOps</strong>, <strong>Python Backend Development</strong>, and <strong>Test Automation Engineering</strong>. My career began in UI automation testing, and I’ve since transitioned into DevOps, focusing on improving development efficiency and infrastructure.</p><p>My early career experiences are quite repetitive, so I’ll share a video of my talk at the PyCon developer conference instead of detailing them here. It provides a comprehensive overview: <a href="https://www.bilibili.com/video/BV1Wv411b7Gm">My PyCon Shenzhen Talk: Joining a Tencent-backed Mid-sized Company, Summarizing My First 2 Years of Work Experience, and Advice for Newcomers</a>.</p><p>我是 李红睿 （Li Hongrui），曾任职于多家纳斯达克上市公司，担任 DevOps 和 Python 后端工程师。最近一份工作是在 <strong>声网（Agora，NASDAQ: API）</strong> 担任研发效率开发工程师。</p><p>2024 年末被裁员后，我一直在积极寻找 <strong>DevOps</strong>、<strong>Python 后端开发</strong> 和 <strong>测试开发</strong> 相关的职位。我的职业生涯从 UI 自动化测试开始，后来逐渐转向 DevOps，专注于提升研发效率和基础设施优化。</p><p>早期经历重复度很高，因此放一个我在 pycon 开发者大会中的演讲视频，里面有详细的介绍，就不在此赘述，<a href="https://www.bilibili.com/video/BV1Wv411b7Gm">我在pycon深圳的演讲：进腾讯投资的中厂、总结前2年工作心得和对新人的建议</a>。</p><hr><h3 id="Seeking-a-New-Job"><a href="#Seeking-a-New-Job" class="headerlink" title="Seeking a New Job"></a>Seeking a New Job</h3><p>I’m currently looking for roles in <strong>DevOps</strong>, <strong>Python Backend Development</strong>, and <strong>Test Automation Engineering</strong>. If you’re hiring or know of any opportunities, feel free to reach out!</p><p>我正在寻找 <strong>DevOps</strong>、<strong>Python 后端开发</strong> 和 <strong>测试开发</strong> 相关的职位。如果你有合适的职位或机会，欢迎联系我！</p><hr><h3 id="Skills-Learning"><a href="#Skills-Learning" class="headerlink" title="Skills &amp; Learning"></a>Skills &amp; Learning</h3><ul><li><strong>Strengths</strong>: Proficient in Python, end-to-end development experience, quick learner, adaptable. </li><li><strong>Weaknesses</strong>: Broad but not deep technical stack; I’m actively working on deepening my expertise in key areas.</li><li><strong>Current Focus</strong>: AI in DevOps (AIOps), Kubernetes, and Python backend development.</li><li><strong>English</strong>: Fluent in business English communication (emails, meetings), though technical vocabulary needs more practice in work scenarios.</li></ul><br><ul><li><strong>优点</strong>: 熟悉 Python 生态，有多段端到端开发经验，在UI自动化测试、运维开发、k8s云平台搭建等业务均有 0-1 的经验，学习能力强，适应能力强，最后 OKR 都完成了。</li><li><strong>缺点</strong>: 技术栈广而不深，急需一份相对稳定的业务、或者足够有深度的业务来精进技术，使我达到“行业前列”的水准。</li><li><strong>当前重点</strong>: AI 在 DevOps 中的应用（AIOps）、Kubernetes 和 Python 后端开发。</li><li><strong>英语</strong>: 日常的邮件、口语会议交流没问题，能进行商务英语沟通，但专业词汇还需要业务场景的锻炼才能更加熟练。</li></ul><p><img src="https://gou7ma7.github.io/images/heatmap.png" alt="heatmap"></p><p>The tech industry is rapidly evolving, especially with the rise of AI. During my job search, I’ve realized that simply relying on past experiences isn’t enough. In one interview with a top-tier global company, I aced the technical rounds but was challenged during the leadership interview: “Don’t just talk about AI in your side projects. Show us how you can learn and integrate new technologies into our needs.” This was a wake-up call for me. I’ve decided to embrace the AI revolution, whether it’s deploying AI products or using AI to optimize traditional DevOps workflows.</p><p>I’m now focused on building a solid foundation while staying ahead of industry trends. I’ve even deleted my 4-year-old blog to start fresh, rediscovering the joy of learning and documenting my journey. Check out my <a href="https://gou7ma7.github.io/2025/02/05/heatmap/index/">Skill Tree</a> to see my learning roadmap.</p><p>最近找工作时，发现很多岗位已经有了 AI 相关的需求。最近面某家国际一流公司，前面技术面都秒过了，结果领导面的时候被质疑了：”我问你 AI 相关的经历，不是总听你说你用 AI 做了啥副业，我更想听你怎么快速学习我们需要的技术，怎么把它们整合到现有业务里。”</p><p>虽然缺乏业务环境导致我只能在我的副业工作流里面落实 AI ，但既然企业想要这方面的人才，那我至少也应该先自行学习，那位领导所说的“技术对每个人都是公平的”，我深以为然，并且要落实。</p><p>我现在一边打基础，一边追新趋势。连写了 4 年的博客都删了，重新开始学习打卡，感觉又找回了当初学习的那种新鲜劲儿。进度在<a href="https://gou7ma7.github.io/2025/02/05/heatmap/index/">技能树</a><br><a href="https://gou7ma7.github.io/2025/02/05/heatmap/index/">https://gou7ma7.github.io/2025/02/05/heatmap/index/</a></p><hr><h3 id="Let’s-Connect"><a href="#Let’s-Connect" class="headerlink" title="Let’s Connect!"></a>Let’s Connect!</h3><p>Feel free to reach out via <a href="https://www.linkedin.com/in/%E7%BA%A2%E7%9D%BF-%E6%9D%8E-a2a612157/">LinkedIn</a> or <a href="https://space.bilibili.com/776431">Bilibili</a>. Let’s collaborate and grow together!</p><p><a href="https://github.com/anuraghazra/github-readme-stats"><img src="https://github-readme-stats.vercel.app/api/top-langs/?username=gou7ma7" alt="Top Langs"></a></p><p><img src="https://github-readme-stats.vercel.app/api?username=gou7ma7&show_icons=true" alt="Anurag&#39;s GitHub stats"></p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python + DevOps -&gt; AIOps Learning Progress Heatmap</title>
    <link href="/2025/02/05/heatmap/index/"/>
    <url>/2025/02/05/heatmap/index/</url>
    
    <content type="html"><![CDATA[<p>After being laid off for the third time and going through dozens of interviews, I need to deeply reflect on how to establish myself in this industry.<br>第三次被裁员后，经历了几十场面试后，需要深入思考自己应该如何立足这个行业。</p><p>The demand for AI-related positions is increasing, mainly divided into deploying AI products themselves or using AI to optimize traditional DevOps processes.<br>AI 相关的岗位要求越来越多，看下来主要分为部署 AI 产品本身，或者使用 AI 优化传统 DevOps 流程。</p><span id="more"></span><p>At the beginning of interviews, I would gloss over with “no project experience in past business” and thought I should solidify fundamentals rather than chase trends.<br>刚开始面试的时候，我还在以”过往的业务经历中没有项目实践一笔带过”，并且想着应该夯实基础，而不是追赶潮流。</p><p>Until interviewing with a top global company - I aced the technical rounds but was challenged during leadership interview: “Don’t talk about AI implementation in your side projects, I want to hear about your learning and integration of new technologies we need” - exposing my lack of AI competencies required for the role.<br>直到面某全球一流公司时，前面技术都面秒过，却在领导面的时候，被质疑”不要讲 AI 在你的副业中的落地，我想听到的是你对我们需要的新事物的学习和整合”代表的岗位需要的 AI 相关的能力不足。</p><p>This was a wake-up call. I always wanted to join companies beyond routine business coding, yet wasn’t prepared for open-ended questions when they came.<br>这对我造成了极大冲击，总是想找个不是整天光写业务的公司，但真的问开放问题的时候又没准备好。</p><p>Interviews test job fit beyond just skills. While I preach about keeping up with times, I default to “never used in production” when challenged.<br>面试本身是对这个岗位要求的匹配，不只是能力的筛选，平时总是说到要跟上时代不能被淘汰，到了这个时候又搪塞以”工程上没用过”。</p><p>This must change. Whether for future interviews or daily learning, isolated self-study won’t cut it anymore.<br>I have to delete the blog I’ve been writing for the past 4 years and start fresh with checking in for learning. It seems like I can regain that fresh feeling I had when I first started learning.<br>不能这样了，不管是以后的面试，还是平时学习，闭门造车始终是不行的。<br>不得不删除之前写了 4年 的 Blog，重新开始打卡学习，看来也能找回刚学习的时候那种新鲜感了。</p><div id="heatmap" style="width: 100%;height:800px;"></div><!-- 引入热力图组件 --><script type="module" src="/js/heatmap.js"></script><p>The learning progress is divided into five stages: Beginner, Explorer, Theorist, Practitioner, and Proficient.</p><ul><li><strong>Beginner</strong>: Installed&#x2F;Used the component.</li><li><strong>Explorer</strong>: Written an article about it.</li><li><strong>Theorist</strong>: Understood the underlying principles.</li><li><strong>Practitioner</strong>: Applied the component effectively in projects.</li><li><strong>Proficient</strong>: Mastery of the component, capable of teaching and leading others in its use.</li></ul><h1 id="the-second-half-of-2025"><a href="#the-second-half-of-2025" class="headerlink" title="the second half of 2025"></a>the second half of 2025</h1><div class="markmap-wrap"                 >      <script type="application/json">{"content":"AIOps","children":[{"content":"<a href=\"https://roadmap.sh/python\">Python</a>","children":[{"content":"&#x5b50;&#x8282;&#x70b9;","children":[],"payload":{"tag":"li","lines":"2,3"}}],"payload":{"tag":"li","lines":"1,3"}},{"content":"<a href=\"https://roadmap.sh/ai-engineer\">ai-engineer</a>","children":[],"payload":{"tag":"li","lines":"3,4"}},{"content":"<a href=\"https://roadmap.sh/devops\">DevOps</a>","children":[],"payload":{"tag":"li","lines":"4,5"}}],"payload":{"tag":"li","lines":"0,5"}}</script>      <script type="application/json">{}</script>    </div><h1 id="Abandoned"><a href="#Abandoned" class="headerlink" title="Abandoned"></a>Abandoned</h1><ul><li>Selenium 异步标签页池：使用 Puppeteer&#x2F;Playwright 完成，避免业务耦合。</li><li>StudyFlow 可视化技能树项目：<ol><li>先将需要打卡的知识点放到一个 data.json</li><li>再使用 Echarts 渲染一个棵 js 代码中表达的树 （后改成热图）</li><li>进而在 markdown 中被引用</li><li>同时使用 Puppeteer 渲染这段 js 代码，将生成的这棵树的 .png 文件保存到 source&#x2F;images 目录下，能够用做文章头图，或者被首页引用</li><li>至于打卡部分，就使用 iOS 原生的日历app，再定期总结规划即可，没有必要非要形式上搞一个前后端工程</li></ol></li><li>Study Map: 逛 v2ex 时发现 <a href="https://roadmap.sh/">https://roadmap.sh/</a> 惊为天人，已经完成了我一直想要的游戏化一样的学习指导和进度跟踪，学习最重要的就是不能闭门造车。</li></ul><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    
    <tags>
      
      <tag>Skill</tag>
      
      <tag>AIOps</tag>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/04/hello-world/"/>
    <url>/2025/02/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在工作6年之际总结业务与技能点</title>
    <link href="/2024/05/18/career/review-2024/"/>
    <url>/2024/05/18/career/review-2024/</url>
    
    <content type="html"><![CDATA[<p>再也不是毕业在即两眼一黑，更不是初入职场惶恐不安的状态了。<br>不知不觉已经6年工作六年，在3年的时候拍了<a href="https://www.bilibili.com/video/BV1b7411B7YR">第一个 vlog </a>，那个时候说三年应该跨过新手期，深耕一个领域，现在看来没有辜负当时的期待。<br>迄今，我的职业生涯从成都小公司做 python 后端 + 爬虫，经过深圳上海做 效能 &#x2F; DevOps，现在定居上海，基本快完成从小就“想进入世界一流公司的梦想”了。</p><span id="more"></span><h1 id="迷茫的学生时代"><a href="#迷茫的学生时代" class="headerlink" title="迷茫的学生时代"></a>迷茫的学生时代</h1><p>中学就在开始参加竞赛，但基于我懒散随性的性格，也没搞出什么名堂，当时某个拿满分的队友，毕业就进入当时还没有那么出名的字节跳动（当时好像还叫头条），我却连自己能不能进入这个行业都在怀疑。</p><p>大学的时候曾有机会跟着老师做地质相关的图形图像处理，最后也只夸夸其谈没有坚持下来。<br>临近毕业还去面试完美世界的客服，回过头来还是觉得当时太浮躁了。</p><h1 id="惶恐的初入职场"><a href="#惶恐的初入职场" class="headerlink" title="惶恐的初入职场"></a>惶恐的初入职场</h1><p>没有参与校招，前三份工作都是成都的（符合对西南柬埔寨刻板印象的）小公司，可以说我的起点很低了。<br>符合城情的试用期不买社保，根本不存在的职业规划和晋升途径。在我多次痛苦挣扎之后均都在差不多第3个月的时候跑路，导致我当时的简历乱七八糟，向未来能看到的只有迷雾。</p><p>摸索中学到了：<br>1st ： python 后端开发， 团队职业分工，调用别人 api；<br>2nd ： 网页模拟点击操作， 爬虫， 开放 api， 封装代码， 数据展示相关的 dashboard；<br>3st ： 权责分明， 破除名校光环， 职场自保， 对梦想的方向坚定不移；</p><h1 id="辗转的适应社会"><a href="#辗转的适应社会" class="headerlink" title="辗转的适应社会"></a>辗转的适应社会</h1><p>挣扎过后觉得日子不能这样过下去了。几经波折找到成都一家正规的做机票代理的公司。</p><p><strong>成都公司</strong>： docker 打包， restful api， 微服务，多线程，重构代码。</p><p>再后来就是疫情来了被裁，发现成都根本找不到工作，然后接到了深圳一家上市公司的 offer ，现在无时不刻不在觉得这是一个影响深远的决定。</p><p>到了深圳公司。<br>一开始业务是在测试开发相关，是让我解决 过量膨胀的 testcase 的问题，加上探索新一代的 testcase runner（基于 nlp, cv, or ?），以及作为甲方私有化地部署购买的服务；<br>随着业务的发展，进而为开始搭建 客户端app 流水线，维护物理agent机器，以及串起来 CI 相关的各种组建，再加上 CD 相关的服务；</p><p><strong>深圳公司</strong>： Jenkins， php， vue， cicd。</p><p>一个机缘巧合下来上海了，又是一个全新的领域，虽然岗位还是叫 DevOps，但是按照某些公司的定位应该是 SRE，即我认为的“线上稳定性保证”。</p><p><strong>上海公司</strong>：kubernetes， 云服务商，continuous development， 发版平台。</p><h1 id="成熟且明确的规划"><a href="#成熟且明确的规划" class="headerlink" title="成熟且明确的规划"></a>成熟且明确的规划</h1><p>也是一个缘分，被上家公司裁员之后，本来拿出了半年准备面试，结果没几天接到的第三个 offer 就感觉挺合适的，就直接去了，社保都无缝衔接。</p><p>背景相当于本来有一个团队负责类似 客户端 &#x2F; 大前端 cicd 这种业务线，然后整个团队都没了。<br>于是在开始的半年我就用了近乎全部的精力去当客服，少的时候几十个，多的时候同时面对上百个人的同步咨询。<br>还能用的服务，把文档和使用文档整理出来；不能用的服务，排期进行恢复。<br>那段时间压力非常大，总会有几个人同步的消息请求过来，不管是去处理谁的事情了，总有人没法得到相应。经常凌晨四五点就醒了睡不着，主要是人只有一个，要做的事情却太杂了。</p><p>现在很多同事经常都和我打趣说不知道我当时是怎么扛下来的，以及当时终于盼来我之后，经常看我状态是否是 （已跑路）。<br>当时下至一线同事，上至HRBP看到我来了都笑嘻嘻地表示终于有人填坑。<br>很多业务开发同事开始报复性提需求，也经常把我当客服发泄自己搞不定又根本不该我管的来分散我的精力。<br>多亏了当时的领导，帮我挡下了很多不合理的需求，以及授权我在文档详实的情况下拒绝同事期待的手把手帮教写代码的无理需求。</p><p>接下来做了一次组织架构调整，也招到了人，终于才能有时间看看 《深入理解计算机系统》；<br>点一下从成都正规公司就早有耳闻的 Goland 技能点。</p><p>我现在也算有了相对清晰的职业规划。<br>首先我真的是一个不挑业务的人，不知道为什么总有人听到我说这个的时候会感到诧异，工作这么多年，哪次不是收拾行囊进入新的业务领域，不都是软件开发工程么，有的只是业务上的区别。<br>其次大方向是 内部平台（或者说所谓的中台），不管是所谓的发版平台，效能 统计 &#x2F; 展示 &#x2F; 运维 &#x2F; 自动化平台，或者说 all in one 的 CICD 流水线平台开发；<br>亦或者 云上 SRE k8s 这一套。<br>这些都是我多年的业务经验领域，比较熟悉了，出现新的工具上手也很快。<br>当然如果让我回去做测开也是一样的，因为我始终觉得 测试，或者说质量保证是 效能 &#x2F; DevOps 很重要的一环。<br>最后我是真的不挑业务，有机会做什么大数据，AI相关开发当然更好。</p><p>随着 Copilot &#x2F; ChatGPT 的普及，技术上手门槛只会越来越低，像刚毕业那会儿学个新东西还是翻文档，再在耐不住的时候狂看相关视频，痛苦地搞个个把月，但现在直接就可以上手业务代码，一边翻译一边询问，哪怕是从来没有用过的语言，在见多识广的 AI 帮助下，直接先写项目。<br>等积累了一定经验，再回头系统的找资料学习，先不说提升的效率，基本上都不再会有以前那种需要摸索找切入点，然后痛苦的在繁杂而陌生的知识图谱中打转的学习状态了。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevOps Toolchain Integration Setup</title>
    <link href="/2023/04/30/devops/devops_toolchain_integration/"/>
    <url>/2023/04/30/devops/devops_toolchain_integration/</url>
    
    <content type="html"><![CDATA[<h1 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h1><p>作为个人工作中实际用到的DevOps相关工具链的整合搭建，同时也作为新手上手DevOps的Quick Setup。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>长话短说:</p><ul><li><p>数据分析师: 作为一名<strong>数学专业</strong>的划水学生，毕业之后无比<strong>憧憬</strong>能成为一名“数据分析师”，然后被<strong>忽悠</strong>到“信老师”（化名，具体内容可以参见<a href="https://www.bilibili.com/video/BV1Wv411b7Gm">我的一个视频总结</a>）旗下工作；</p></li><li><p>爬虫：老师告诉我，<strong>数据平台还没搭建好</strong>，这样吧，你先自己去<strong>公网上爬取数据</strong>；</p></li><li><p>爬虫 *2： 第一份正式的工作，技术栈是<strong>自动化</strong>的请求接口 &#x2F; <strong>操作浏览器界面</strong>完成业务；</p></li><li><p>测试开发 + DevOps：凭借上述后者，找到了<strong>UI自动化测试开发</strong>的工作；再在工作中要用到<strong>整合流水线</strong>为业务开发同事提供服务，于是职位变成了DevOps；</p></li><li><p>DevOps：来到上海成为专职DevOps，负责Daily CI&#x2F;CD &amp; Release platform 的搭建。</p></li></ul><p>之前的工作中部分组件是我去的时候已经安装、配置好了的，因此在这里把用到的工具链进行全流程的安装，回顾并系统的梳理技术栈，同时也作为新手上手DevOps的Quick Setup。</p><span id="more"></span><h1 id="机器"><a href="#机器" class="headerlink" title="机器"></a>机器</h1><p>Ubuntu 实体机 *2 （不要用WSL）</p><p>一个作为master，另一个作为node，搭建一个最小的集群。</p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p>之前业务上主要使用的是阿里云容器服务Kubernetes版（Alibaba Cloud Container Service for Kubernetes，简称容器服务ACK）</p><p>同时在私有化部署的时候使用<a href="https://kubesphere.io/zh/">kubesphere</a>，本文主要使用后者进行物理机上的部署。</p><p><a href="https://gou7ma7.github.io/2023/05/11/devops/Kubernetes/">Kubernetes Setup in Local Physical Servers</a></p><h1 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h1><p>The package manager for Kubernetes</p><p>简单来说，我的包管理方式经过一下迭代</p><ol><li>exe &#x2F; other executable file &#x2F; tar &amp; scp;</li><li>Docker Image;</li><li>Helm Charts;</li></ol><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不要用WSL，否则会变得不幸</title>
    <link href="/2023/04/30/devops/no_wsl/"/>
    <url>/2023/04/30/devops/no_wsl/</url>
    
    <content type="html"><![CDATA[<p>有位前辈用“Linux本身不要钱，但是你（折腾）的时间更费钱”来形容Linux上可能遇到的适配问题，从而表达自己对该系统又爱又恨的感情。</p><p>而寄宿在Windows上的WSL，更是将这个说法发挥到极致。</p><p>在我自己从头搭建Kubernetes工具链的时候，由于家境贫寒，本想就着手上4台老旧PC搭建个基本能用的集群就行，结果在Windows里面装WSL，以及WSL里面装Kubernetes的时候，遇到太多看不到尽头的问题，遂放弃。</p><p>目前我的解决方案是安装Ubuntu系统到其中2台PC，至少先跑起来一个最小的主从集群。</p><p>而本次我本身就是为了学习才搭建环境，因此记录下遇到的WSL相关的问题，以便学有余力的时候更加透彻的掌握操作系统相关的知识。</p><span id="more"></span>``<h1 id="WSL的适用范围"><a href="#WSL的适用范围" class="headerlink" title="WSL的适用范围"></a>WSL的适用范围</h1><p>写写Python代码，搭建普通的前后端应用，WSL是非常合适的，甚至避免了在Windows上安装软件的麻烦事。</p><p>但是在涉及到底层的东西，比如说虚拟化、容器化、集群化等这种需要用到“网卡”之类硬件的配置的时候，WSL这类基于Hyper-v的“精简版”虚拟机就会变得缺胳膊少腿，有早年用过“番茄花园”这种精简版Windows打游戏然后缺少组件经历的朋友就能体会到我的感受。</p><h1 id="最好的是物理机，其次是真正的虚拟机"><a href="#最好的是物理机，其次是真正的虚拟机" class="headerlink" title="最好的是物理机，其次是真正的虚拟机"></a>最好的是物理机，其次是真正的虚拟机</h1><p>这几天我一直在满是坑的泥泞中匍匐，很多问题要么是没有通用解法，要么是试下来根本不管用。</p><p>最后学习阶段只推荐VMware、VirtualBox这种成熟得不能再成熟的真正的虚拟机，如果不信欢迎自行尝试。</p><h1 id="systemd与systemctl"><a href="#systemd与systemctl" class="headerlink" title="systemd与systemctl"></a>systemd与systemctl</h1><p>systemd是一个Linux系统的初始化系统和服务管理器;</p><p>而systemctl是systemd的一个命令行工具，用于控制systemd系统和服务管理器。</p><p>systemctl可以启动、停止、重启、重载、状态检查、启用或禁用系统服务。</p><p>WSL2本身是由Windows负责运行的，因此使用tree或ps命令时会看到根进程不是systemd，这将导致无法启动Linux系统服务的守护进程(deamon)。当我们执行systemctl命令的时候，会显示出我们的init system (PID 1)并非systemd，而是微软提供的init system。</p><p>即使在&#x2F;etc&#x2F;wsl.conf添加systemd&#x3D;true配置等操作也会有各种问题。</p><h2 id="service代替systemctl"><a href="#service代替systemctl" class="headerlink" title="service代替systemctl"></a>service代替systemctl</h2><p>虽然有些时候能够通过service代替systemctl，但是有些时候会出现<code>Failed to connect to bus: No such file or directory</code>的错误。</p><p>比如我跑一个自动安装docker &#x2F; 自动开启ssh的脚本的时候，由于源头默认提供的脚本是使用systemctl的，还是绕不开这个问题。</p><p>如果我去批量替换别人的脚本，又会带来新的问题。</p><h1 id="WSL2无法连接网络"><a href="#WSL2无法连接网络" class="headerlink" title="WSL2无法连接网络"></a>WSL2无法连接网络</h1><h2 id="Windows-automatically-generates-resolv-conf-file-with-wrong-nameserver"><a href="#Windows-automatically-generates-resolv-conf-file-with-wrong-nameserver" class="headerlink" title="Windows automatically generates resolv.conf file with wrong nameserver"></a>Windows automatically generates resolv.conf file with wrong nameserver</h2><p><a href="https://stackoverflow.com/questions/62314789/no-internet-connection-on-wsl-ubuntu-windows-subsystem-for-linux">https://stackoverflow.com/questions/62314789/no-internet-connection-on-wsl-ubuntu-windows-subsystem-for-linux</a><br>Locate the file by running the following command:</p><p><code>sudo vim /etc/resolv.conf</code></p><p>You will see the following in the file:</p><h1 id="This-file-was-automatically-generated-by-WSL-To-stop-automatic-generation-of-this-file-add-the-following-entry-to-etc-resolv-conf"><a href="#This-file-was-automatically-generated-by-WSL-To-stop-automatic-generation-of-this-file-add-the-following-entry-to-etc-resolv-conf" class="headerlink" title="This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to &#x2F;etc&#x2F;resolv.conf"></a>This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to &#x2F;etc&#x2F;resolv.conf</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># [network]</span><br><span class="hljs-comment"># generateResolvConf = false</span><br>nameserver xxx.xx.xx<br></code></pre></td></tr></table></figure><p>Change the nameserver value to 8.8.8.8 and save the file. You should now be able to connect to the internet.</p><h2 id="winsock"><a href="#winsock" class="headerlink" title="winsock"></a>winsock</h2><p><a href="https://github.com/microsoft/WSL/issues/3438#issuecomment-41051857">https://github.com/microsoft/WSL/issues/3438#issuecomment-41051857</a><br>Open Command Prompt as an Administrator and type these commands:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">netsh winsock reset <br>netsh int ip reset all<br>netsh winhttp reset proxy<br>ipconfig /flushdns<br>Reboot your machine.<br></code></pre></td></tr></table></figure><p>完成之后一定重启WSL，否则修改不生效。</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>WSL2可以直接用Windows的命令行直接进入，也可以通过VSCode的WSL插件直接本地连接WSL；</p><h2 id="无法Set-Bridge-Network"><a href="#无法Set-Bridge-Network" class="headerlink" title="无法Set Bridge Network"></a>无法Set Bridge Network</h2><p>在正统的虚拟机配置设置Bridge Network都是点一键就能拿完成的工作，我无法在WSL上完成，虽然各种教程都说在Windows上的Hyper-v管理器上设置一下就好了，但是如果真的是这样的话，就不会有这篇文章了。</p><h2 id="kex-exchange-identification-Connection-closed-by-remote-host"><a href="#kex-exchange-identification-Connection-closed-by-remote-host" class="headerlink" title="kex_exchange_identification: Connection closed by remote host"></a>kex_exchange_identification: Connection closed by remote host</h2><p>在WSL2中开启sshd服务之后，连接自己机器上的WSL2只需要通过<code>ssh localhost</code>就可以；</p><p>连接局域网中另一个PC物理机上的WSL2就会出现标题标错，还有更离谱的timeout，我尝试过很多，就没成功过（多半是因为上面Set Bridge Network没成功导致的）。</p><h1 id="Transport-endpoint-is-not-connected"><a href="#Transport-endpoint-is-not-connected" class="headerlink" title="Transport endpoint is not connected"></a>Transport endpoint is not connected</h1><p>导致这个问题的原因太多了，不断重启LxssManager服务可能会暂时可用一下，我就是被这个问题搞得彻底放弃的。</p><p>LxssManager是Windows 10中的一个服务，它支持运行本机ELF二进制文件。该服务提供在Windows上运行ELF二进制文件所需的基础结构。WSL是Windows Subsystem for Linux的缩写，它是一个允许在Windows 10上运行Linux二进制文件的兼容层。LxssManager是WSL的一部分，它负责管理WSL的Linux发行版。</p><h1 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h1><p>首先部署Kubernetes的机器不能开启swap，因为在写入虚拟内存的时候会影响性能和造成系统卡顿；</p><p>于是在实体机上只需要<code>sudo swapoff -a</code>简单一步的操作，在WSL上死活不起作用，推测是WSL的swap是由Windows上的某个专门负责虚拟化的服务进行配置的，然后由于问题太过偏门，尝试了之后没有找到轻松有效的方法。</p><h1 id="Ubuntu-桥接接入局域网固定IP"><a href="#Ubuntu-桥接接入局域网固定IP" class="headerlink" title="Ubuntu 桥接接入局域网固定IP"></a>Ubuntu 桥接接入局域网固定IP</h1><h2 id="入网方式"><a href="#入网方式" class="headerlink" title="入网方式"></a>入网方式</h2><p>一般虚拟机软件都提供多种网络模式，主要有：</p><p>NAT模式： 虚拟机没有直接接入局域网，和集群里面的Node宿主机互相ping不通，<strong>不选</strong></p><p>Bridged Adapter模式：即桥接模式，为虚拟机模拟出一个独立的网卡，有独立的IP地址接入局域网，<strong>选</strong></p><h2 id="固定IP"><a href="#固定IP" class="headerlink" title="固定IP"></a>固定IP</h2><p>当虚拟机使用桥接模式接入局域网之后，就和物理机Ubuntu的设置一样了。</p><p>Ubuntu 18.04 LTS之后的版本使用&#x2F;etc&#x2F;netplan&#x2F;下得文件来配置网络，我这里叫01-network-manager-all.yaml。</p><p>首先使用<code>ifconfig</code>查看当前机器的网络情况，找到桥接的网卡名称，我这里是<code>enp0s3</code>；</p><p>然后使用<code>sudo vim /etc/netplan/01-network-manager-all.yaml</code>打开配置文件，添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Let NetworkManager manage all devices on this system</span><br>network:<br>  ethernets:<br>    enp0s3:  <span class="hljs-comment">#配置的网卡的名称</span><br>      addresses: [192.168.31.50/24]  <span class="hljs-comment">#配置的静态ip地址和掩码</span><br>      dhcp4: no  <span class="hljs-comment">#关闭DHCP，如果需要打开DHCP则写yes</span><br>      optional: <span class="hljs-literal">true</span><br>      routes:<br>        - to: 0.0.0.0/0<br>          via: 192.168.31.1  <span class="hljs-comment">#网关地址</span><br>      nameservers:<br>         addresses: [192.168.31.1]  <span class="hljs-comment">#DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开</span><br>  version: 2<br>    <span class="hljs-comment"># renderer: NetworkManager</span><br>  renderer: networkd  <span class="hljs-comment">#指定后端采用systemd-networkd或者Network Manager</span><br></code></pre></td></tr></table></figure><p>networkd和NetworkManager都是用于管理网络接口的后端。networkd是systemd的一部分，它是一个轻量级的网络管理器，可以在Ubuntu 18.04及更高版本中使用。它使用Netplan配置文件来配置网络接口。NetworkManager是一个更高级的网络管理器，可以在Ubuntu 16.04及更高版本中使用。它提供了一个GUI界面，可以方便地配置网络接口。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Setup in Local Physical Servers</title>
    <link href="/2023/04/30/devops/setup_kubernetes/"/>
    <url>/2023/04/30/devops/setup_kubernetes/</url>
    
    <content type="html"><![CDATA[<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>在我自己在作为一名初学者学习编程的时候，曾看到过一位前辈在知乎日报中写道：</p><p>他们当年学习编程痛苦在根本找不到参考资料，只能自己硬着头皮摸索前进，不过好处是每个方向的技术选型基本上是固定的，不会有纠结；</p><p>而现在的初学者在一开始学习编程，就会很容易迷失在面对浩如烟海的技术路线选择中，尤其是热门的方向，总有前人做好了各种版本的教程、工具，完全不知道从哪里开始。</p><p>在我一开始学习DevOps的时候背过官方推荐的minikube教程， 到后来也尝试过搭建轻量化的k3s环境，算上业务中的阿里云容器服务Kubernetes版（Alibaba Cloud Container Service for Kubernetes，简称容器服务ACK），最终发现“搭建环境”本身也是造轮子的一部分，对提高<strong>理解应用能力</strong>甚微。</p><p>因此本文选择最简单的一种方式：<br><a href="https://kubesphere.io/zh/docs/v3.3/quick-start/all-in-one-on-linux/">在 Linux 上以 All-in-One 模式安装 KubeSphere</a>（以下简称<strong>官方文档</strong>），直接最简化地安装，然后再在使用中进行学习，毕竟<strong>背诵任何的学习资料都不如自己动手部署一遍</strong>。</p><span id="more"></span><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文仅供学习使用，生产环境请使用云服务厂商提供的成熟的Kubernetes环境。</p><h1 id="Master-Node"><a href="#Master-Node" class="headerlink" title="Master Node"></a>Master Node</h1><p>Ubuntu 实体机 in roy-qtc6（有些时候master node的名字可能是这个），这是一台2013年刚上大学时候买的HASEE 神舟 精盾 K580S-i7D1，三千六就拿到当时平民级最强的CPU和显卡，甚至到10年后的今天不管是装Windows娱乐还是装Linux学习性能都充裕，对比一会儿提到的同龄人简直是扬我国威。</p><p>按照<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/all-in-one-on-linux/">官方文档</a>中的步骤进行安装。</p><p>由于kubernetes与kubesphere之间存在一个版本匹配问题，因此我这里直接使用example中推荐的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./kk create cluster --with-kubernetes v1.22.12 --with-kubesphere v3.3.2<br></code></pre></td></tr></table></figure><p>当运行上述命令时，会检查机器是否安装依赖。</p><p>  在我这台机器上，只需要预先手动安装conntrack socat ebtables ethtool，其他组件会自动安装。</p><pre><code class="hljs">`$ apt-get install conntrack socat ebtables ethtool`</code></pre><table><thead><tr><th>name</th><th>sudo</th><th>curl</th><th>openssl</th><th>ebtables</th><th>socat</th><th>ipset</th><th>ipvsadm</th><th>conntrack</th><th>chrony</th><th>docker</th><th>containerd</th><th>nfs client</th><th>ceph client</th><th>glusterfs client</th></tr></thead><tbody><tr><td>master</td><td>y</td><td>y</td><td>y</td><td>y</td><td>y</td><td></td><td></td><td>y</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>查看log会发现 在依次安装kubelet、kubectl、helm、kubecni、crictl、etcd、docker等，在之后的教程里，会解释组件的作用。</p><p>经过漫长的等待之后，当console中出现Welcome hints、ip地址与默认admin账号密码， 就表示Kubenets安装完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ Welcome to KubeSphere!<br></code></pre></td></tr></table></figure><p>这个时候可以登录<a href="http://ip:30880/dashboard">http://ip:30880/dashboard</a> 进行可视化操作。</p><p>以上安装过程基本上是一键安装，在物理机器与Ubuntu系统没有太大问题的情况下，一小时之内能完成。</p><p>如果要安装官方的Kubernetes Dashboard的话，还需要手动安装、并配置外部访问与账号，这些额外的概念无疑会在一开始极大的增加初学者的负担。</p><p>而这些步骤&#x2F;组件 <strong>KubeSphere全家桶</strong>全都集成了，让开发者将更多的经历集中在理解与应用k8s核心组件与部署业务代码上。</p><p>接下来可以跟着官方文档应用学习其中组件了。</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><h3 id="WARNING-FileExisting-ethtool-ethtool-not-found-in-system-path"><a href="#WARNING-FileExisting-ethtool-ethtool-not-found-in-system-path" class="headerlink" title="[WARNING FileExisting-ethtool]: ethtool not found in system path"></a>[WARNING FileExisting-ethtool]: ethtool not found in system path</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ apt-get install ebtables ethtool<br></code></pre></td></tr></table></figure><p>这两个依赖是必须的，但是官方文档中没有列出来。</p><h3 id="kubectl-Please-wait-for-the-installation-to-complete"><a href="#kubectl-Please-wait-for-the-installation-to-complete" class="headerlink" title="kubectl Please wait for the installation to complete"></a>kubectl Please wait for the installation to complete</h3><p>安装的一直卡在这个命令，推测可能是kube-system中的k8s自己的pod没有就绪，另外启动一个shell查询pod状况；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get pod -A<br>NAMESPACE           NAME                                           READY   STATUS    RESTARTS   AGE<br>...<br>kube-system         openebs-localpv-provisioner-57bbf864d5-zhl6k   0/1     Pending   0          26m<br>kubesphere-system   ks-installer-85d6fb8c97-mns4d                  0/1     Pending   0          26m<br></code></pre></td></tr></table></figure><p>查看其中一个pod的Events</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl describe pod openebs-localpv-provisioner-57bbf864d5-zhl6k -n kube-system<br>Name:           openebs-localpv-provisioner-57bbf864d5-zhl6k<br>...<br>Events:<br>  Type     Reason            Age                 From               Message<br>  ----     ------            ----                ----               -------<br>  Warning  FailedScheduling  97s (x35 over 36m)  default-scheduler  0/1 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io/master: &#125;, that the pod didn<span class="hljs-string">&#x27;t tolerate.</span><br></code></pre></td></tr></table></figure><p>发现openebs-localpv-provisioner与ks-installer的STATUS均是Pending，通过Events里面的描述，发现是因为有taints所以pod调度不上去。</p><p>查看node的taints</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get nodes -o json | jq <span class="hljs-string">&#x27;.items[].spec&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;taints&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;effect&quot;</span>: <span class="hljs-string">&quot;NoSchedule&quot;</span>,<br>      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;node-role.kubernetes.io/master&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;effect&quot;</span>: <span class="hljs-string">&quot;NoSchedule&quot;</span>,<br>      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;node.kubernetes.io/not-ready&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>means that no pod can be scheduled on the master node unless it has a toleration for this taint123， 意思就是说不能在master节点上的和not-ready的pod不允许调度到我这个节点上。</p><p>The OpenEBS Local PV provisioner is designed to run on worker nodes and not on master nodes1. If you want to deploy the OpenEBS Local PV provisioner on a master node, you can do so by adding the label openebs.io&#x2F;engine&#x3D;provisioner to the master node2. However, it is not recommended to run the provisioner on master nodes as it can cause issues with the Kubernetes control plane</p><p>污点（Taint）是 Kubernetes 中的一个概念，它是一种标记，用于标识节点上的一些特殊条件，例如节点上的硬件故障或其他不可用性。 污点可以阻止 Pod 调度到具有特定污点的节点上。 有关更多信息，请参见<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/">官方文档</a>。</p><p>Taints and Tolerations 是一起组合使用的，相当于“黑名单”机制，前者配置在nodes上，只能配置过后者的pod；</p><pre><code class="hljs">简单但是不推荐的做法： 将taints删除</code></pre><blockquote><p>:warning: <strong>不如直接用minikube单节点部署</strong>: 这里的意思是这个pod不能调度在master节点上，如果删了这个污点，相当于是强行调度在master上了。</p></blockquote><p>执行<code>kubectl taint nodes --all node-role.kubernetes.io/master-</code>, 这个命令是在将所有节点的node-role.kubernetes.io&#x2F;master 污点删除，以便可以在这些节点上调度非 master Pod。</p><p>然后发现唯一node上的taint没有了(这里换一个方法查看taints)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl describe node master | grep Taints<br>Taints:             &lt;none&gt;<br></code></pre></td></tr></table></figure><pre><code class="hljs">正规做法：先跳过这个pod的安装，参照下文先安装一个worker node并注册到cluster，然后再重复安装步骤安装。</code></pre><p>完成安装worker node并注册到cluster后，验证查看当前nodes</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get nodes<br>NAME             STATUS   ROLES                  AGE    VERSION<br>worker           Ready    worker                 9h     v1.22.12<br>master           Ready    control-plane,master   4d3h   v1.22.12<br></code></pre></td></tr></table></figure><p>当看到出现STATUS为Ready的worker时候，就可以再执行<code>./kk create cluster --with-kubernetes v1.22.12 --with-kubesphere v3.3.2</code>，然后经过漫长的等待即可。</p><h1 id="Worker-Node"><a href="#Worker-Node" class="headerlink" title="Worker Node"></a>Worker Node</h1><p>Ubuntu 实体机 in roy-macbookair（有些时候worker node的名字可能是这个），这是一台2013款的具有10年历史的老机器，陪我拿到了第一家上市公司的offer，但目前已经无法正常运行macOS，因此安装Ubuntu（图形化模式略微卡顿，使用命令行模式才能流畅运行k8s）。</p><p>按照<a href="https://kubesphere.io/zh/docs/v3.3/installing-on-linux/introduction/multioverview/">在 Linux 上多节点安装</a>中的步骤进行安装。</p><p>将一台新准备好的Linux物理机， 作为Node（不管Worker是Master）添加到cluster只需要KubeKey + SSH 就能完成。</p><p>那么同样地，先安装相关地依赖<br><code>$ apt install conntrack socat ebtables ethtool</code></p><p>然后在当前目录下创建一个config-sample.yaml的文件（这一步可以在新机器的终端上完成，也可也在已有集群的任意一个物理机的终端上完成）<br><code>$ ./kk create config</code></p><p>在我这里，config-sample.yaml的内容如下，其中的ssh相关的信息需要自己填写，这里我使用的是密码登录，因此需要填写密码，如果使用的是ssh key登录，则不需要填写密码（但是需要配置ssh-key）。</p><p>然后按照教程中的配置文件，结合自己的node name与ip，修改配置文件，然后执行<code>$ ./kk create cluster -f config-sample.yaml</code>（集群未安装）&#x2F; <code>/kk add nodes -f sample.yaml</code>（集群已安装），等待一段时间后，集群就安装好了。</p><p>在经过以上操作后，可以看到我成功的创建了一个一共拥有3个Node的Cluster，就可以开始自己的kubenets操作了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">13:09:53 CST success: [roy-qtc6]<br>13:09:53 CST success: [roy-300]<br>13:09:53 CST success: [roy-macbookair]<br>13:09:53 CST Pipeline[AddNodesPipeline] execute successfully<br>❯ kubectl get nodes<br>NAME             STATUS   ROLES                  AGE     VERSION<br>roy-300          Ready    worker                 2m41s   v1.22.12<br>roy-macbookair   Ready    worker                 23h     v1.22.12<br>roy-qtc6         Ready    control-plane,master   4d18h   v1.22.12<br></code></pre></td></tr></table></figure><p>安装出了问题也别急，<code>./kk delete cluster</code>解君愁。</p><h1 id="角色、权限等配置"><a href="#角色、权限等配置" class="headerlink" title="角色、权限等配置"></a>角色、权限等配置</h1><p>就像大多数成熟的管理系统一样，初始化安装之后会分配一个admin账户，然后再通过该账户创建一个业务账户，之后大多数操作都应该通过业务账户进行操作。</p><p>而这些概念、操作在每个云平台上略有不同，且不影响k8s的核心组件，同时又都是基本都能在Web UI进行点点点操作，所以本段略。</p><p>可以参考<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/create-workspace-and-project/">在kubesphere创建企业空间、项目、用户和平台角色</a></p><h1 id="外部访问"><a href="#外部访问" class="headerlink" title="外部访问"></a>外部访问</h1><p>在安装好Cluster之后，可以看到每个Node连接的IP地址是10开头的，这个明显是Kubernetes Cluster的IP地址， 不是外部可以访问的IP地址，因此需要一个网关来提供外部访问。</p><h2 id="启动网关"><a href="#启动网关" class="headerlink" title="启动网关"></a>启动网关</h2><p>网关是在项目中运行的 <a href="https://github.com/kubernetes/ingress-nginx">NGINX Ingress 控制器</a>。</p><p><a href="https://www.kubesphere.io/zh/docs/v3.3/pluggable-components/service-mesh/">在安装后启用服务网格</a></p><pre><code class="hljs">本段为KubeSphere的配置，其他云平台可能不同</code></pre><p>使用定制资源定义（CRD）里面的clusterconfiguration的ks-installer进行安装，看名字就知道是KubeSphere自己的，其他云平台没有。</p><h2 id="提供外部访问"><a href="#提供外部访问" class="headerlink" title="提供外部访问"></a>提供外部访问</h2><p><a href="https://www.kubesphere.io/zh/docs/v3.3/cluster-administration/cluster-settings/cluster-gateway/">设置集群网关</a><br>访问模式设置为 NodePort，选择确定之后，集群网关详情里面会出现一个和宿主机网段相同的局域网网关IP地址（在我这里是192开头的），这个是可以访问的。</p><p><a href="https://www.kubesphere.io/zh/docs/v3.3/multicluster-management/enable-multicluster/retrieve-kubeconfig/#%E8%8E%B7%E5%8F%96-kubeconfig">通过使用 kubeconfig 文件配置访问集群</a><br>除了上面链接中的方法外，还可以在KubeSphere UI右下角的工具箱图标上悬停，然后在弹出菜单中选择 kubeconfig，点击右上角的下载按钮，就可以直接下载连接K8s的kubeconfig.yaml。</p><p>特别注意的是需要把Cluster里面的server IP替换为局域网的IP</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">cluster:</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://10.233.0.1:443</span>  <span class="hljs-comment"># 替换为集群网关详情里面和宿主机网段相同的局域网网关IP地址</span><br></code></pre></td></tr></table></figure><h1 id="KubeSphere-DevOps-系统"><a href="#KubeSphere-DevOps-系统" class="headerlink" title="KubeSphere DevOps 系统"></a>KubeSphere DevOps 系统</h1><pre><code class="hljs">本段为KubeSphere的配置，其他云平台可能不同，步骤在[KubeSphere DevOps 系统](https://kubesphere.io/zh/docs/v3.3/pluggable-components/devops/)</code></pre><p>KubeSphere全家桶的DevOps 系统基于 Jenkins 的 KubeSphere DevOps 系统是专为 Kubernetes 中的 CI&#x2F;CD 工作流设计的，它提供了一站式的解决方案，帮助开发和运维团队用非常简单的方式构建、测试和发布应用到 Kubernetes。(得了，感觉以前的工作又是造轮子了，这叫深度业务定制开发！)</p><blockquote><p>:warning: <strong>整个集群内存最好25Gi以上</strong>: 我一开始安装的时候就遇到了各种卡住且没有提示的问题，其实就是内存不够，但是增加内存是需要硬件成本的，排查的时候花了很多的精力和时间。</p></blockquote><h2 id="Troubleshooting-1"><a href="#Troubleshooting-1" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>在之前工作中用过实体机上的Jenkins，也用过k8s节点中的Jenkins，但从来没用过全家桶的Jenkins，因此本段就算安装不上，也完全不影响使用。</p><h3 id="安装一直卡住，没有任何提示与报错"><a href="#安装一直卡住，没有任何提示与报错" class="headerlink" title="安装一直卡住，没有任何提示与报错"></a>安装一直卡住，没有任何提示与报错</h3><p>很自然去查看pod状况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get pod -n kubesphere-devops-system<br>devops-jenkins-c8b495c5-4hqwf        0/1     Pending     0          19h<br><br>❯ kubectl describe pod devops-jenkins-c8b495c5-4hqwf -n kubesphere-devops-system<br>...<br>Containers:<br>  devops-jenkins:<br>...<br>    Requests:<br>      cpu:      2<br>      memory:   2Gi<br>Events:<br>  Type     Reason            Age    From               Message<br>  ----     ------            ----   ----               -------<br>  Warning  FailedScheduling  69m    default-scheduler  0/1 nodes are available: 1 node(s) had taint &#123;node.kubernetes.io/memory-pressure: &#125;, that the pod didn<span class="hljs-string">&#x27;t tolerate.</span><br></code></pre></td></tr></table></figure><p>（这里有时Events里面会是空的，就只能靠其他信息推测了）</p><p>但是很神奇的是查看node本身并没有添加任何污点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ kubectl get nodes -o json | jq <span class="hljs-string">&#x27;.items[].spec.taints&#x27;</span><br>null<br></code></pre></td></tr></table></figure><p>然后再仔细审视<code>describe pod devops-jenkins</code>pod的描述，报错是内存pressure，多半是内存不足，然后惊讶地发现需要2Gi的内存，而我的传家宝MacBook Air只剩下可怜的不到1Gi，由于这是物理资源的不足，无法弥补，要么放弃体验KubeSphere DevOps全家桶，要么只能自己在另一台物理机&#x2F;node上安装jenkins。</p><p>一想到某人那种32Gi的电脑沉迷召唤师峡谷，就想悄悄给装一个Ubuntu上去996.</p><p>（2天后更新： 结果把自己的神船刷Ubuntu了，然后去给朋友搬家捡了的PC）</p><p>整一些内存大的电脑添加到Cluster 成为Node就好了。</p><p>实测发现要装KubeSphere DevOps 系统最好还是保证整个集群内存有25Gi以上的容量，否则会出现各种问题，为此时隔十多年我又玩起了虚拟机，这里<strong>只推荐正统的VMware，VirtualBox</strong>这种，否则虚拟化的大坑欢迎您。</p><h1 id="Cluster-Uninstall"><a href="#Cluster-Uninstall" class="headerlink" title="Cluster Uninstall"></a>Cluster Uninstall</h1><p>当Cluster出现某些问题，且安装上面的排查依旧不能解决的时候，就使用重装大法，DevOps的其中一个特质就是无状态、重装方便，在应用部署上这是巨大的进步。</p><p>首先需要一个config-sample.yaml来配置集群的信息，比如Master &#x2F; Worker Node 的IP，账户等，如果没有的话，<code>./kk create config-sample.yaml</code>生成一下新的。</p><p>然后<code>./kk delete cluster -f config-sample.yaml</code></p><p>接着SSH到每一台Worker Node机器上，进行<a href="https://stackoverflow.com/questions/44698283/how-to-completely-uninstall-kubernetes">深度清理</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm reset<br><span class="hljs-built_in">sudo</span> apt-get purge kubeadm kubectl kubelet kubernetes-cni kube*   <br><span class="hljs-built_in">sudo</span> apt-get autoremove  <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf ~/.kube<br></code></pre></td></tr></table></figure><p>上面这个命令是把包都干掉了（而且实测不用重启机器就生效）</p><p>If you are clearing the cluster so that you can start again, then, in addition do the following to ensure my systems are in a state ready for kubeadm init again:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm reset -f<br><span class="hljs-built_in">rm</span> -rf /etc/cni /etc/kubernetes /var/lib/dockershim /var/lib/etcd /var/lib/kubelet /var/run/kubernetes ~/.kube/*<br>iptables -F &amp;&amp; iptables -X<br>iptables -t nat -F &amp;&amp; iptables -t nat -X<br>iptables -t raw -F &amp;&amp; iptables -t raw -X<br>iptables -t mangle -F &amp;&amp; iptables -t mangle -X<br>systemctl restart docker<br></code></pre></td></tr></table></figure><p>这个时候就算清理干净了，最后再回到Master Node机器上，执行<code>./kk create cluster -f config-sample.yaml</code>，等待一段时间后，集群就重新安装好了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本文历时半个月，从4月13号被干掉，休息半个月，5月1号开始搭环境，经过了半个月走走停停，不断地试错，查资料，写总结，才终于在5月20号地今天完成这个学习计划的开头 ————环境搭建。</p><p>这一个月里，有耍到接近昏迷，也有一天4个场面试的高强度，有点回到了快毕业那会的节奏。只是再也不像当初那么无助，迷茫而又没用行动力了。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hard 4. Median of Two Sorted Arrays -- 第一道Hard，做了5年。</title>
    <link href="/2022/05/29/leetcode/4_hard%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/05/29/leetcode/4_hard%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我最重要的一道题，第一次遇到看题解也无法理解的题，想起了以前高中去竞赛划水的日子，想起了在大学划水地没有去竞赛的日子。</p><p>第一次看到这个题的时候，我还不知道做工程分前端和后端，我还可能只有170斤，我还看着Java代码觉得太丑陋看不懂；</p><p>后来小付快速的把这题理解并做出来了，我还是没有足够的行动力，后来就开始了一系列的迷茫的日子；</p><p>这么多年过去了，只有山东大哥的红轴Cherry键盘一直陪着我，他拿这键盘打Dota，考研；我拿这把键盘打Lol，假装考研；又在磨子桥的电脑城被我的老乡阵修理+魔改；然后在成都摸鱼，在深圳打字。</p><p>有很多变化了，又有很多没有变，不过看样子我的行动力确实螺旋上升了。</p><span id="more"></span><h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:</p><p>nums1 &#x3D; [1, 3]<br>nums2 &#x3D; [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 &#x3D; [1, 2]<br>nums2 &#x3D; [3, 4]</p><p>The median is (2 + 3)&#x2F;2 &#x3D; 2.5</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="保底算法"><a href="#保底算法" class="headerlink" title="保底算法"></a>保底算法</h2><p>先排序再找中位数，由于python的sort()使用的是快排，所以o(n)&#x3D;log(n)，不过揣摩出题人意图，肯定不是想考察这个知识点。</p><h2 id="分析类型"><a href="#分析类型" class="headerlink" title="分析类型"></a>分析类型</h2><p>分析之后不难得出，本题的目的是找出2个有规律的数组中的一个有特征的值，稍微思考之后能够得出可以用分治法；</p><p>原因为： 中位数实际上只与整个数组中位置最中间的两个数有关系，因此2个数组的共同中位数也只会与最多2数组中各取2个数（共计4个数）有关系，而其他部分都可以剪枝。</p><h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        nums1_small = nums2_small = <span class="hljs-number">0</span><br>        nums1_big = <span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span><br>        nums2_big = <span class="hljs-built_in">len</span>(nums2) - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span> nums1_big - nums1_small + nums2_big - nums2_small &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># TODO 一头一尾一个个删除</span><br><br>        <span class="hljs-comment"># 只剩下其中一个列表</span><br>        <span class="hljs-keyword">if</span> nums1_small &gt; nums1_big:<br>            <span class="hljs-keyword">return</span> (nums2[nums2_small] + nums2[nums2_big]) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums2_small &gt; nums2_big:<br>            <span class="hljs-keyword">return</span> (nums1[nums1_small] + nums1[nums1_big]) / <span class="hljs-number">2</span><br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">max</span>(nums1[nums1_small], nums2[nums2_small]) + <span class="hljs-built_in">min</span>(nums1[nums1_big], nums2[nums2_big])) / <span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>有了上述思路之后不难写出最初版本的伪代码：既找出分治原子，然后不断缩小问题规模；<br>体现在本题中就是：每次判断2数组两端4个数字，淘汰掉其中最大和最小的2数；然后当其中一个数组无法再淘汰数时</p><h2 id="分治原子有问题"><a href="#分治原子有问题" class="headerlink" title="分治原子有问题"></a>分治原子有问题</h2><p>跑了几个用例之后发现不正确，因为按照上述算法只有把其中一个数组中的数全部淘汰完了才是分治原子，这是不符合中位数定义的，因为每一个数组的最中间的2个数都是有成为“共同中位数”的可能的，因此分治原子条件应当是任意一个数字的长度小于2；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_mid</span>(<span class="hljs-params">nums</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                len_nums = <span class="hljs-built_in">len</span>(nums)<br>                left = (len_nums - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>                right = len_nums // <span class="hljs-number">2</span><br>                <span class="hljs-keyword">return</span> (nums[left] + nums[right]) / <span class="hljs-number">2</span><br><br>        len1 = <span class="hljs-built_in">len</span>(nums1)<br>        len2 = <span class="hljs-built_in">len</span>(nums2)<br>        <span class="hljs-keyword">while</span> len1 &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> len2 &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># TODO 一头一尾一个个删除</span><br>        <span class="hljs-keyword">if</span> len1 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> get_mid(nums2)<br>        <span class="hljs-keyword">if</span> len2 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> get_mid(nums1)<br>        <br>        <span class="hljs-comment"># TODO 解决其他分治原子问题</span><br><br>        <span class="hljs-keyword">return</span> get_mid(nums1)<br></code></pre></td></tr></table></figure><p>中间其实经过了长达一个星期的思考和尝试，在这里意义不大就不展开了，毕竟距离我第一次看这个题已经过去5年；</p><p>主要解决以下问题：</p><ol><li>摒弃中学时代的“下标处理数组模式”，都做了这么多年工程了，还是要明白可读性是远比”性能“重要的，且最后的时间表也看得出来并没有多少损耗；</li><li>优先处理特殊情况，这个从OJ到工程都是很重要的，这个都忘了那就没啥可说的了；</li><li>分治原子找错了，当其中任意一个数组只剩小于2个数的时候就可以结束分治进入决赛圈了；</li></ol><h2 id="分治原子的优化-O-n-的思辨"><a href="#分治原子的优化-O-n-的思辨" class="headerlink" title="分治原子的优化 &amp; O(n)的思辨"></a>分治原子的优化 &amp; O(n)的思辨</h2><p>在本来的做法中，进入决赛圈后，我是拿其中小的那个数组中剩下的数去和大的数字的两边，中间各个数字进行比较；</p><p>为此还总结了3种情况： 包含在大的中，分离在大的外，与大的交叉，然后又根据这三种情况进一步的分类，试图找出通用的比较规则；</p><p>实际上非常的蠢，是属于自己给自己找麻烦，且实际上的刷题过程中，经常由于这种case过多的情况进行放弃。</p><p>在连续想了一个星期之后，突然发现，对于分治原子来说，最后这一步使用的方法是不会影响到整体的时间复杂度的，且做了这么多年工程，熟练使用轮子的意义远大于反复的抠这几个下标，于是果断使用先合并、排序再找中位数的方法；</p><p>且由于最后决赛圈的中位数说白了还是在小于4个数之间出现，因此这一步O(n)&#x3D;1；</p><p>实际上很多时候思维是会被自己局限的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TODO 解决其他分治原子问题 code</span><br>nums1.extend(nums2)<br>nums1.sort()<br><br><span class="hljs-keyword">return</span> get_mid(nums1)<br></code></pre></td></tr></table></figure><h2 id="分治策略的优化"><a href="#分治策略的优化" class="headerlink" title="分治策略的优化"></a>分治策略的优化</h2><p>跑几个case之后就会发现，实际上对一个数组来说，除了“中间”一点的位置可能产生中位数，其他部位其实都是炮灰；</p><p>再发现数组边上其实很多时候都是在重复淘汰同一边的数，在继续观察之后发现规律：</p><p>先比较两个数组的中位数，同时将2个数组平均分成两份，考虑一下，中位数只可能诞生在两个数组相对“中间”的位置，因此一次性淘汰掉2个数组的两边的部分；</p><p>最后再注意一下边界取值等，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TODO 一头一尾一个个删除</span><br>len1 = <span class="hljs-built_in">len</span>(nums1)<br>len2 = <span class="hljs-built_in">len</span>(nums2)<br><span class="hljs-keyword">while</span> len1 &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> len2 &gt; <span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums1) == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums2) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">break</span><br><br>    mid_1 = get_mid(nums1)<br>    mid_2 = get_mid(nums2)<br>    <span class="hljs-keyword">if</span> mid_1 == mid_2:<br>        <span class="hljs-keyword">return</span> mid_1<br>    <span class="hljs-keyword">elif</span> mid_1 &lt; mid_2:  <span class="hljs-comment"># 砍掉nums1小的和nums2大的部分</span><br>        cut = <span class="hljs-built_in">min</span>((<span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>, (<span class="hljs-built_in">len</span>(nums2) - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>)<br>        nums1 = nums1[cut:]<br>        nums2 = nums2[:len2 - cut]<br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 砍掉nums1大的和nums2小的部分</span><br>        cut = <span class="hljs-built_in">min</span>((<span class="hljs-built_in">len</span>(nums2) - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>, (<span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>)<br>        nums1 = nums1[:len1 - cut]<br>        nums2 = nums2[cut:]<br>    len1 = <span class="hljs-built_in">len</span>(nums1)<br>    len2 = <span class="hljs-built_in">len</span>(nums2)<br><br></code></pre></td></tr></table></figure><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从二叉树遍历到yield</title>
    <link href="/2022/05/29/book/python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2022/05/29/book/python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="yield的作用"><a href="#yield的作用" class="headerlink" title="yield的作用"></a>yield的作用</h1><p>首先yield就是return，不要想多了，所以搭配<code>yield from func()</code>能够递归，就是这么简单；</p><p>只是说普通的函数返回的是一个value或者obj，而yield返回的是一个生成器对象。</p><h2 id="生成器的定义-同迭代器的区别"><a href="#生成器的定义-同迭代器的区别" class="headerlink" title="生成器的定义&amp;同迭代器的区别"></a>生成器的定义&amp;同迭代器的区别</h2><p>在python中实现了__iter__和__next__方法，可以迭代操作的对象就叫迭代器；<br>构建迭代器的时候，并不一次性加载所有元素到内存，只有调用next方法的时候才会<strong>返回</strong>需要的该元素；</p><span id="more"></span><p>生成器就是一种迭代器，由生成器函数返回；<br>生成器函数就是上文中的 return -&gt; yield的函数；  </p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>学以致用，看文档的时候自然说：都懂，都懂，结果自己不仅写不来还看不懂。<br>尤其是再遇到几个yield并排就不会了？</p><h2 id="当一个生成器函数中多个yield并排"><a href="#当一个生成器函数中多个yield并排" class="headerlink" title="当一个生成器函数中多个yield并排"></a>当一个生成器函数中多个yield并排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():  <span class="hljs-comment"># 普通函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():  <span class="hljs-comment"># 生成器函数</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 遍历一个生成器</span><br>it = gen()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        sys.exit()<br></code></pre></td></tr></table></figure><p>要遍历一个生成器，自然需要调用next方法到报错为止，实际上行为和遍历序列的时候下标越界同理，只是现代编译器做好了没意识到而已。  </p><blockquote><p>普通函数func调用：<br><code>print(func())  # 1</code><br><code>print(func())  # 1</code></p></blockquote><blockquote><p>生成器函数调用：<br><code>it = gen();  # 获得一个生成器</code><br><code>print(next(it))  # 1</code><br><code>print(next(it))  # 2</code>  </p></blockquote><h2 id="为啥要用生成器"><a href="#为啥要用生成器" class="headerlink" title="为啥要用生成器"></a>为啥要用生成器</h2><p>从上文中可以看到生成器函数一个巨大的优势就是函数写出来是分块的，可以直接剪掉很多的选择分支，让代码更加的整洁接近算法描述。<br>尤其是当需要递归的时候，使用yield的代码写出来简直就像是伪代码，曾一度让我无法理解其中的逻辑分支和递归基是如何运行的。</p><p>比如使用普通函数实现中序遍历一个BST的伪代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">global_res = []<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):  <span class="hljs-comment"># 定义一个二叉树</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-variable language_">self</span>.val = val<br>        <span class="hljs-variable language_">self</span>.left = left<br>        <span class="hljs-variable language_">self</span>.right = right<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 递归基</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    in_order_visit(node.left)<br>    global_res.append(node.value)<br>    in_order_visit(node.right)<br><br>in_order_visit(root)  <span class="hljs-comment"># root为需要遍历的BST的根节点</span><br><span class="hljs-built_in">print</span>(global_res)<br></code></pre></td></tr></table></figure><h3 id="递归参数只能是对象本身，遍历出来的值无法收集"><a href="#递归参数只能是对象本身，遍历出来的值无法收集" class="headerlink" title="递归参数只能是对象本身，遍历出来的值无法收集"></a>递归参数只能是对象本身，遍历出来的值无法收集</h3><p>可以明显的看得出来，遍历函数本身在递归的过程中<strong>参数只能是node or None</strong>，同时<strong>node &#x3D; None作为递归基</strong>；<br>那么问题来了，我<strong>遍历出来的值</strong>如何返回给上层呢？<br>我当时的函数设计的无比复杂，进入函数的时候先进行一个<strong>逻辑判断</strong>，再选择进入node.left还是返回node.value，因此一个函数就可能<strong>接受2种数据结构</strong>，<br>再根据自己的下面的调用结果判断是该继续往下递归还是往上return。</p><h3 id="需要的值放到递归参数中会导致逻辑十分混乱"><a href="#需要的值放到递归参数中会导致逻辑十分混乱" class="headerlink" title="需要的值放到递归参数中会导致逻辑十分混乱"></a>需要的值放到递归参数中会导致逻辑十分混乱</h3><p>代码无比丑陋，逻辑无比复杂。<br>不得已，只得引入<strong>全局变量</strong>（不引入也可以，可以让遍历函数返回一个元组(node, node.value: list[int])，但本质没变，就是把列表当成指针来用，还是全局，这不pythonic）<br>让遍历函数只专心访问node，我用一个全局变量来储存访问结果（也就是网上教材都只让你print出来的操作）<br>问题是全局变量应该少用，这是破坏结构性的，不管是封装成对象还是闭包还是什么玩意儿；<br>或者不用递归，用循环 + 堆栈来访问这个树，这与本文无关。</p><h3 id="必须将所有节点全部访问到内存"><a href="#必须将所有节点全部访问到内存" class="headerlink" title="必须将所有节点全部访问到内存"></a>必须将所有节点全部访问到内存</h3><p>迭代器可以每次调回的时候再到下一个节点，在有些情况（比如求前n个数），就不用像普通函数这样需要先遍历（排序）整个树，然后再截取需求的部分。</p><h3 id="试图yield实现递归"><a href="#试图yield实现递归" class="headerlink" title="试图yield实现递归"></a>试图yield实现递归</h3><p>使用生成器函数遍历一个BST的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit_gen</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">yield</span> visit_bst(node.left)<br>    <span class="hljs-keyword">yield</span> node.val<br>    <span class="hljs-keyword">yield</span> visit_bst(node.right)<br><br>it = visit_bst(root_node)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br></code></pre></td></tr></table></figure><p>结果非常意外<code>&lt;generator object visit_bst at &#39;addr in mem&#39;&gt;</code><br>为什么呢？<br>其实很简单，因为yield是懒狗，它只会返回一个it（迭代器&#x2F;生成器)，还记得之前的“生成器函数调用”的方法么。<br>每次需要先调用生成器函数，得到一个it，相当于把无产阶级请过来了<code>it = gen()</code><br>然后在调用这个迭代器，才能调用，相当于任务分配下去了<code>print(it)</code></p><p>因此如果yeild接自己想递归的话，第一次下去的时候，就会直接返回一个visit_bst(node.left)，还记得吗，这是一个生成器函数，现在调用它自然只会得到一个迭代器，还需要在外面像“遍历一个生成器”一样不断地用next去调用才能启动。</p><h3 id="yield-from-return-递归"><a href="#yield-from-return-递归" class="headerlink" title="yield from &#x3D; return -&gt; 递归"></a>yield from &#x3D; return -&gt; 递归</h3><p>python好就好在他有足够多的语法糖，在本文中只要粗暴的记得以下等价关系就行<br>yield obj &#x3D; yield from func() &#x3D; return obj&#x2F;func()  # 递归过程<br>相当于yield from就是先调用这个func得到一个it，然后马上就调用这个it一次，因此就得到了递归；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit_gen</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> visit_bst(node.left)<br>    <span class="hljs-keyword">yield</span> node.val<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> visit_bst(node.right)<br><br>it = visit_bst(root_node)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br></code></pre></td></tr></table></figure><h3 id="并排yield-递归表达式"><a href="#并排yield-递归表达式" class="headerlink" title="并排yield -&gt; 递归表达式"></a>并排yield -&gt; 递归表达式</h3><h1 id="TODO-有空再写吧。"><a href="#TODO-有空再写吧。" class="headerlink" title="TODO 有空再写吧。"></a>TODO 有空再写吧。</h1><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
