

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Roy Lee">
  <meta name="keywords" content="">
  
    <meta name="description" content="用最新的模型生成很老的知识点，一种又新又旧的学习体验。  前言这是一篇跨越 3年 又新又旧的文章。（或者说单纯鸽了这么久，上次写作的细节仍历历在目） 当时写作时 ChatGPT 都没落地，为了调一个 Blog 展示效果还得花上许多时间查文档，试实现。 现在 AI 的存在已经让手写 Blog 这种类似以前游戏中为了节省算力资源预先渲染好的的 “过场动画” 大部分时候没什么意义了，想要查询什么知识">
<meta property="og:type" content="article">
<meta property="og:title" content="从二叉树遍历到yield，然后到协程、异步">
<meta property="og:url" content="https://gou7ma7.github.io/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/index.html">
<meta property="og:site_name" content="DevOps -&gt; AI Agent">
<meta property="og:description" content="用最新的模型生成很老的知识点，一种又新又旧的学习体验。  前言这是一篇跨越 3年 又新又旧的文章。（或者说单纯鸽了这么久，上次写作的细节仍历历在目） 当时写作时 ChatGPT 都没落地，为了调一个 Blog 展示效果还得花上许多时间查文档，试实现。 现在 AI 的存在已经让手写 Blog 这种类似以前游戏中为了节省算力资源预先渲染好的的 “过场动画” 大部分时候没什么意义了，想要查询什么知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gou7ma7.github.io/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yield01.png">
<meta property="article:published_time" content="2022-05-29T00:48:59.000Z">
<meta property="article:modified_time" content="2025-12-05T11:59:00.000Z">
<meta property="article:author" content="Roy Lee">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gou7ma7.github.io/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yield01.png">
  
  
  
  <title>从二叉树遍历到yield，然后到协程、异步 - DevOps -&gt; AI Agent</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gou7ma7.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://github.com/gou7ma7/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="从二叉树遍历到yield，然后到协程、异步"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-29 08:48" pubdate>
          2022年5月29日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          42 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">从二叉树遍历到yield，然后到协程、异步</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年12月5日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><img src="/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yield01.png" srcset="/img/loading.gif" lazyload alt="本图由 2025年11月20日 谷歌发布的Nano Banana Pro （Gemini 3 Pro图像）生成"></p>
<blockquote>
<p>用最新的模型生成很老的知识点，一种又新又旧的学习体验。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇跨越 3年 又新又旧的文章。<br>（或者说单纯鸽了这么久，上次写作的细节仍历历在目）</p>
<p>当时写作时 ChatGPT 都没落地，为了调一个 Blog 展示效果还得花上许多时间查文档，试实现。</p>
<p>现在 AI 的存在已经让手写 Blog 这种类似以前游戏中为了节省算力资源预先渲染好的的 “过场动画” 大部分时候没什么意义了，想要查询什么知识点的时候，直接实时生成一篇 Post，通识知识质量还高于绝大多数。</p>
<p>看了一下时间，正好是来上海的第一份工作，封控将要结束，从共享办公室搬到自己租的办公楼时候。</p>
<span id="more"></span>

<p><img src="/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/background.png" srcset="/img/loading.gif" lazyload alt="写作背景"></p>
<blockquote>
<p>这张生成图真的太抽象了，而且我说了我是 2025年3月去的百度，不知道 2023 和 “虚桌” 是什么意思。。。</p>
</blockquote>
<p>那个时候刚刚才接触云服务，又正值 AI 普及方兴未艾，面对公司都是谷歌退下来的老人，没想到自己两年后也会去百度走一遭。</p>
<p>一晃也真的是又 3年 过去了，再不抓紧总结点什么的话，感觉都留不下自己的痕迹。</p>
<p>本文理论部分大规模参考以下视频，甚至可以当成是学习读书笔记。当视频看到第4遍，同时再加上不断地应用 ayscio 相关的架构，总算把这个抽象的概念越看越具体了。</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=726448831&bvid=BV1sS4y1b7qb&cid=718057385&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px;"> </iframe>

<h1 id="yield-是什么"><a href="#yield-是什么" class="headerlink" title="yield 是什么"></a>yield 是什么</h1><blockquote>
<p> yield的作用<br>首先yield就是return，不要想多了，所以搭配<code>yield from func()</code>能够递归，就是这么简单；</p>
<p>只是说普通的函数返回的是一个value或者obj，而yield返回的是一个生成器对象。<br> 生成器的定义&amp;同迭代器的区别<br>在python中实现了__iter__和__next__方法，可以迭代操作的对象就叫迭代器；<br>构建迭代器的时候，并不一次性加载所有元素到内存，只有调用next方法的时候才会<strong>返回</strong>需要的该元素；<br>生成器就是一种迭代器，由生成器函数返回；<br>生成器函数就是上文中的 return -&gt; yield的函数；  </p>
</blockquote>
<p>我当年的说法本身没什么问题，但是太过流于表面，从性质进行总结，而不是真正看它怎么实现的。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>当前我并没有阅读 Python 源码的计划，因此仅在豆包的指导下，涉猎 Objects&#x2F;genobject.c 等文件，理解了调用栈等相关概念的实现部分。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>要想真正知道 yield 是什么，一定要先应用，再来看概念，而不是像传统9年义务教育那样反其道而行之，此处略去应用的部分。</p>
<p>在一定的使用积累之后，我们对这个这个概念的感觉就没有那么抽象了。这个时候再查阅 Python 官方文档 <a target="_blank" rel="noopener" href="https://docs.python.org/3/reference/expressions.html#yield-expressions">https://docs.python.org/3/reference/expressions.html#yield-expressions</a></p>
<div class="note note-info">
            <p>expression： 就像正则表达式，会有返回值的那种。</p><p>statement： 就像 print 语句，不会有返回值。</p><p>这里顺便提一个一个我一直搞混淆的概念 <strong>生成器表达式</strong>，会返回一个生成器。</p><blockquote><p>在以前，我一直把 “列表生成式” 读做了 “列表生成器”，与本处讨论的 “生成器” 产生了不应当的混淆，对我早期学习、与面试造成了巨大的困难。</p></blockquote><p>为了行文统一，我们可以像列表生成式那样，用生成器生成式来称呼它，</p>
          </div>

<p>在文档中提到，当一个正常的 function &#x2F; method 中只要出现了 yield 表达式，它就不再是一个平凡的 function &#x2F; method， 而是一个生成器了。</p>
<p>在这里引入了生成器这个新概念，因此我们先用一点专门的篇幅去讨论。</p>
<h1 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h1><p>生成器是一种迭代器，那么自然地又要先入栈一个新概念。</p>
<h2 id="迭代是什么"><a href="#迭代是什么" class="headerlink" title="迭代是什么"></a>迭代是什么</h2><p>更加自然地，我们再次入栈一个新概念： 迭代，和可迭代对象</p>
<h3 id="迭代是什么-1"><a href="#迭代是什么-1" class="headerlink" title="迭代是什么"></a>迭代是什么</h3><p>首先迭代可以是一个数学的定义，就类似于高中学习的 “递推公式” 中的这种项于项之间的关系。</p>
<p>迭代（英语：iteration），亦作疊代，是重复反馈过程的活动，其目的通常是为了接近并且到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。</p>
<h3 id="可迭代对象是什么"><a href="#可迭代对象是什么" class="headerlink" title="可迭代对象是什么"></a>可迭代对象是什么</h3><p>具体的来说，在 Python 里面，可以跟在 in 关键字后面的就是 <strong>可迭代对象</strong>。</p>
<p>抽象的来说，可迭代对象（Iterable）： 能够被迭代（遍历）的对象，作为 “数据容器”，提供迭代的 “数据来源”，但不负责迭代的具体逻辑（如 “如何获取下一个元素”“是否迭代结束”）</p>
<p>按照视频中的拆解 Python 实现后发现，实现了 <code>__iter__ </code> 方法，用来随时返回容器里面的数据的对象，就叫做可迭代对象。而且也满足上述定义：能返回自身作为被迭代的对象，且不需要知道对象之间（如何迭代）关系。</p>
<h2 id="迭代器是什么-1"><a href="#迭代器是什么-1" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h2><p><img src="/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yield02.jpg" srcset="/img/loading.gif" lazyload alt="可迭代对象和迭代器的区别"></p>
<blockquote>
<p>很明显的能够看到，由于可迭代对象（Iterable）只是 “数据容器”，且不知道迭代逻辑，因此不具备 “惰性计算” 的能力，还是一股脑加载到内存里面的。</p>
</blockquote>
<p>在可迭代对象的基础上，再实现 <code>__next__ </code> 方法，体现出对象之间（如何迭代）关系，就得到了迭代器。</p>
<p>具体的来说：迭代器（Iterator）： 实现了迭代协议（Iterator Protocol）的对象，是 “迭代的具体执行者”—— 负责按顺序生成下一个元素、记录迭代状态、判断迭代结束。</p>
<p>正如同常见的 递推公式 需要知道 自己 和 之后其他项 之间（如何迭代）关系，因此迭代器 除了也有 <code>__iter__ </code> 方法返回它自身以外， 还有 <code>__next__ </code> 方法返回之后（如何迭代）关系的 “其他项”。</p>
<blockquote>
<p>最贴合迭代概念的数据结构就是链表，可以通过 head指针 指向自己，再通过 self.next 属性指向下一个被迭代的项。</p>
</blockquote>
<p>我们现在讲完了迭代器这个还算能有具体数据结构能对应的概念，但是我们先不急着扩展到生成器，先按照文章开头说的，应用一下。</p>
<h1 id="yield-怎么应用"><a href="#yield-怎么应用" class="headerlink" title="yield 怎么应用"></a>yield 怎么应用</h1><p>同样我们先从我们最熟悉的普通函数入手，看看我们能怎么实现迭代这个动作。</p>
<h2 id="手动实现迭代这个动作概念"><a href="#手动实现迭代这个动作概念" class="headerlink" title="手动实现迭代这个动作概念"></a>手动实现迭代这个动作概念</h2><p>在这里我们设定一个最简单的目标： 在不借助额外数据结构的帮助下，如何迭代地输出 1, 2, 3。</p>
<blockquote>
<p>迭代地输出，意味着我们要运行3次这个函数，并且每次依次返回 1, 2, 3，一次性返回肯定是不可以的。 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():  <span class="hljs-comment"># 普通函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><span class="hljs-built_in">print</span>(func())<br><span class="hljs-built_in">print</span>(func())<br><span class="hljs-built_in">print</span>(func())<br></code></pre></td></tr></table></figure>
<p>很自然地，我们发现 return 之后的代码不会执行，因此我们只能引入分支实现输出不同的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():  <span class="hljs-comment"># 普通函数 + 分支</span><br>    <span class="hljs-keyword">if</span> exection_count == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> exection_count == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> exection_count == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><span class="hljs-built_in">print</span>(func())<br><span class="hljs-built_in">print</span>(func())<br><span class="hljs-built_in">print</span>(func())<br></code></pre></td></tr></table></figure>
<p>想法很自然，报错的时候就发现，我们并没有定义这个用来计数的 exection_count。</p>
<p>最简单的做法就是把 exection_count 设计成一个全局变量，并且每次执行就增加一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">exection_count = <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():  <span class="hljs-comment"># 普通函数 + 分支 + 全局变量（用来计数）</span><br>    <span class="hljs-keyword">if</span> exection_count == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> exection_count == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> exection_count == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><span class="hljs-built_in">print</span>(func())<br>exection_count += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(func())<br>exection_count += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(func())<br></code></pre></td></tr></table></figure>

<blockquote>
<p>当然这样实现的代码 func 很不独立，也有把这个 exection_count 放到 func 里面并自动 +1 的办法，这里不展开，对本文来说没有区别。</p>
</blockquote>
<h2 id="用-yield-实现迭代这个动作概念"><a href="#用-yield-实现迭代这个动作概念" class="headerlink" title="用 yield 实现迭代这个动作概念"></a>用 yield 实现迭代这个动作概念</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():  <span class="hljs-comment"># 生成器函数</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br><br>it = gen()<br><span class="hljs-built_in">print</span>(it)  <span class="hljs-comment"># &lt;generator object gen at 0x1066d0a90&gt;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))  <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))  <span class="hljs-comment"># 3</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))  <span class="hljs-comment"># StopIteration</span><br></code></pre></td></tr></table></figure>

<p>还记得链表吗，在不追求严谨，仅为了形象的情况下，现在假设我们有一个最典型的 空值节点 作为表头的一个链表， 这个空值节点，也就是头节点，就是这里单纯为了标记整个生成器起点的 <code>it = gen()</code>，然后我们需要依次遍历整个链表，就需要移动沿着链表的<strong>迭代关系</strong>移动指针看，也是同样用的 <code>next</code>。</p>
<p>最后链表的尾节点的 next 指向了一个 None，再对 None.next 就会报错。</p>
<div class="note note-warning">
            <p>这里就没必要贴图了，假如对链表都不熟悉，那就应该去刷题，而不是再看 yield 这个概念。</p>
          </div>


<p>同样的，优雅地遍历生成器很自然地就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():  <span class="hljs-comment"># 生成器函数</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br><br>it = gen()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        sys.exit()<br></code></pre></td></tr></table></figure>

<h1 id="yield-与树的遍历-写本文的契机"><a href="#yield-与树的遍历-写本文的契机" class="headerlink" title="yield 与树的遍历 - 写本文的契机"></a>yield 与树的遍历 - 写本文的契机</h1><h2 id="中序遍历一个BST"><a href="#中序遍历一个BST" class="headerlink" title="中序遍历一个BST"></a>中序遍历一个BST</h2><p>BST 是 二叉搜索树（Binary Search Tree）的缩写，也称为二叉查找树或二叉排序树。它的核心特性是：任何一个节点的左子树中所有节点的值都小于该节点的值，而右子树中所有节点的值都大于该节点的值；并且它的左、右子树本身也都是二叉搜索树。</p>
<p>其实这里用二叉树就可以了，但 leetcode 上用的 BST，就原封不动抄过来了。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>说起来这也是我刚毕业的时候面试微软的第一道题一个类型。</p>
<p>当访问完了一个结点准备访问它子节点的时候，很自然的接着访问 .left 或者 .right 就行。</p>
<p>但是这时把 visit 指针挪开了，自己当前的位置就丢掉了，比如我现在访问 .left ，等访问结束的时候，我如何才能继续访问 .right呢？</p>
<p>很自然的，我们需要一个清单来维护先后访问节点的顺序，不至于一旦开始访问，就丢掉了现在的位置。</p>
<h2 id="使用普通函数实现-（栈）"><a href="#使用普通函数实现-（栈）" class="headerlink" title="使用普通函数实现 （栈）"></a>使用普通函数实现 （栈）</h2><p>首先有个大原则，就是选择好访问辅助 “清单” 的数据结构，当时面试微软时，我就是没有第一时间想起，浪费时间搞了心态。</p>
<p>其次我们都知道在《数据结构》这门课里面会学到遍历一个数据结构的时候，有 深度优先(DFS) 和 广度优先(BFS) 两种方式，如果不清楚可以先 上课 + 刷题。</p>
<p>然后很科学的是，先人设计出了 <strong>FIFO(先进先出)的队列</strong>，可以遍历的时候先放入当前节点，然后依次放入子节点（暂时不访问），进入子节点之前，再统一访问队列中的节点，这样就把本来树中不能直接体现的层级关系体现了出来；</p>
<p>同时还设计出了 <strong>LIFO(后进先出)的栈</strong>，专门用于深度优先遍历。栈的核心思想是”<strong>后进先出</strong>“：最后放入栈的元素最先被访问，这让栈天然适合实现深度优先的访问模式。</p>
<p>最后和本文 栈 和本文主题关系密切，必须单独一个章节描述。</p>
<h3 id="为什么栈能够实现深度优先遍历？"><a href="#为什么栈能够实现深度优先遍历？" class="headerlink" title="为什么栈能够实现深度优先遍历？"></a>为什么栈能够实现深度优先遍历？</h3><p>栈的LIFO特性决定了访问顺序：<strong>优先处理最近遇到的节点</strong>。这种特性天然地实现了”<strong>深度优先</strong>“的遍历策略——总是沿着当前路径走到最深，再回退处理其他分支。</p>
<p>举个例子，对于树结构 <code>A -&gt; (B, C)</code>，<code>B -&gt; (D, E)</code>：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">    <span class="hljs-variable">A</span><br>   <span class="hljs-operator">/</span> \<br>  <span class="hljs-variable">B</span>   <span class="hljs-built_in">C</span><br> <span class="hljs-operator">/</span> \<br><span class="hljs-built_in">D</span>   <span class="hljs-built_in">E</span><br></code></pre></td></tr></table></figure>

<p><strong>栈的工作过程</strong>：</p>
<ul>
<li>先将根节点A入栈</li>
<li>弹出A，访问A，并将A的子节点按<strong>右左顺序</strong>入栈：先C后B（这样B会在C之前被访问）</li>
<li>弹出B，访问B，并将B的子节点按<strong>右左顺序</strong>入栈：先E后D</li>
<li>弹出E，访问E（E是叶子节点，无子节点可入栈）</li>
<li>弹出D，访问D（D是叶子节点，无子节点可入栈）</li>
<li>弹出C，访问C（C是叶子节点，无子节点可入栈）</li>
</ul>
<p>最终访问顺序：<strong>A → B → D → E → C</strong>，完美实现了深度优先遍历。</p>
<h3 id="队列-vs-栈的本质区别"><a href="#队列-vs-栈的本质区别" class="headerlink" title="队列 vs 栈的本质区别"></a>队列 vs 栈的本质区别</h3><ul>
<li><strong>队列(FIFO)</strong>：保证<strong>层级顺序</strong>，先遇到的节点先处理子节点，实现广度优先</li>
<li><strong>栈(LIFO)</strong>：保证<strong>深度优先</strong>，后遇到的节点先被处理，优先探索深度方向</li>
</ul>
<p>总结一下：<br>队列 vs 栈 都是辅助我们记住当前遍历属性的 “清单”， 发生在我们访问到当前节点，将要进入下一个节点之前。</p>
<p>现在让我们看看具体的栈实现： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):  <span class="hljs-comment"># 定义一个二叉树</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-variable language_">self</span>.val = val<br>        <span class="hljs-variable language_">self</span>.left = left<br>        <span class="hljs-variable language_">self</span>.right = right<br><br>value_list = [random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(value_list)<br><br>node = TreeNode(value_list.pop(<span class="hljs-number">0</span>))<br>node.left = TreeNode(value_list.pop(<span class="hljs-number">0</span>))<br>node.right = TreeNode(value_list.pop(<span class="hljs-number">0</span>))<br>node.left.left = TreeNode(value_list.pop(<span class="hljs-number">0</span>))<br>node.left.right = TreeNode(value_list.pop(<span class="hljs-number">0</span>))<br>node.right.left = TreeNode(value_list.pop(<span class="hljs-number">0</span>))<br>node.right.right = TreeNode(value_list.pop(<span class="hljs-number">0</span>))<br><br>result = []<br>stack = []<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-comment"># 从根节点开始，一直往左走，将路径上的节点都压入栈</span><br>    current = node<br>    <span class="hljs-keyword">while</span> current <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> stack:<br>        <span class="hljs-comment"># 先遍历左子树，将所有左节点压入栈</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            stack.append(current)<br>            current = current.left<br><br>        <span class="hljs-comment"># 弹出栈顶节点（最左边的节点）</span><br>        current = stack.pop()<br>        result.append(current.val)<br><br>        <span class="hljs-comment"># 转向右子树</span><br>        current = current.right<br><br>    <span class="hljs-keyword">return</span> result<br><br><br><span class="hljs-comment"># 测试中序遍历</span><br>result = in_order_visit(node)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;中序遍历结果:&quot;</span>, result)<br><br><span class="hljs-comment"># 验证结果是否正确 - 中序遍历应该得到升序排列（如果树是BST的话）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;排序验证:&quot;</span>, <span class="hljs-built_in">sorted</span>([n.val <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> [node, node.left, node.right, node.left.left, node.left.right, node.right.left, node.right.right]]))<br><br><span class="hljs-comment"># 打印树结构</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_tree</span>(<span class="hljs-params">node, level=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-keyword">if</span> node:<br>        print_tree(node.right, level + <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &#x27;</span> * <span class="hljs-number">4</span> * level + <span class="hljs-string">&#x27;-&gt;&#x27;</span>, node.val)<br>        print_tree(node.left, level + <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n树结构:&quot;</span>)<br>print_tree(node)<br></code></pre></td></tr></table></figure>
<p>我这里写完了才发现是普通二叉树，而不是搜索的，鉴于题中给定的是构造好的树，且在本文中没有区别，就不管了。</p>
<h2 id="使用递归实现"><a href="#使用递归实现" class="headerlink" title="使用递归实现"></a>使用递归实现</h2><p>递归的思想这里不展开了，请咨询查阅《数据结构》，这里想表述的是，递归会自动维护一个栈，当在函数中调用自身的时候，会将当前的变量和状态都封存到这个栈的一个帧中，因此不需要手动维护 stack &#x3D; [] 这个全局变量了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 递归基</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># 按照中序遍历的</span><br>    in_order_visit(node.left)  <span class="hljs-comment"># 如果有左子树，则先访问左子树</span><br>    <span class="hljs-built_in">print</span>(node.val)  <span class="hljs-comment"># 走到这里说明访问过左子树了，现在要访问当前节点</span><br>    in_order_visit(node.right)  <span class="hljs-comment"># 最后访问右子树</span><br><br>in_order_visit(node)<br></code></pre></td></tr></table></figure>

<p>优雅，无需多言。 而且甚至还高度抽象，非常直观地符合中序遍历的定义。</p>
<h2 id="生成器实现"><a href="#生成器实现" class="headerlink" title="生成器实现"></a>生成器实现</h2><p>既然递归可以自行维护一个栈，那么我们是不是还可以更进一步，再抽象一个高度，解放双手呢？</p>
<p>是的可以的。</p>
<p>前文已经说过使用 yield 之后，原来的函数就成为一个生成器，能够使用的时候再把栈帧加载到内存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit_gen</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 有错的版本</span><br>    <span class="hljs-keyword">yield</span> visit_bst(node.left)<br>    <span class="hljs-keyword">yield</span> node.val<br>    <span class="hljs-keyword">yield</span> visit_bst(node.right)<br><br><br>it = in_order_visit_gen(node)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>

<p>当我们运行的时候，惊讶的发现，并没有像刚刚那样，直接优雅的递归进去，而是仅仅返回了生成器（不接着递归了）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;generator object in_order_visit_gen at 0x1083ff940&gt;<br>26<br>&lt;generator object in_order_visit_gen at 0x1083ff940&gt;<br></code></pre></td></tr></table></figure>

<p>简单来说，想要递归一个生成器的时候，要额外使用 yield from 关键字， 优雅的提供了判断， 如果还能 next() 则递归进去， 如果到底了，则自动处理 StopIteration。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_order_visit_gen</span>(<span class="hljs-params">node: TreeNode</span>):  <span class="hljs-comment"># 最终版本，优雅，简洁</span><br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> in_order_visit_gen(node.left)<br>    <span class="hljs-keyword">yield</span> node.val<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> in_order_visit_gen(node.right)<br><br><br>it = in_order_visit_gen(node)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<p>最终版本连递归都不需要我们维护，正如递归会自动维护一个栈一样，递归一个生成器的时候它会自动维护相关上下文，又向上屏蔽了一些细节。</p>
<h1 id="由-yield-from-走向协程"><a href="#由-yield-from-走向协程" class="headerlink" title="由 yield from 走向协程"></a>由 yield from 走向协程</h1><p>yield from 额外还有 双向通信 的特点，本文知识点已经够多了，这里就先省略。</p>
<h2 id="生成器和迭代器的区别"><a href="#生成器和迭代器的区别" class="headerlink" title="生成器和迭代器的区别"></a>生成器和迭代器的区别</h2><p>话说这是之前遇到很高频的面试问题了，以前并没有系统的学习过，也只是从用法上进行了一些回答，回想起来不甚满意。</p>
<p><img src="/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yield03.png" srcset="/img/loading.gif" lazyload alt="迭代器和生成器的区别"></p>
<p>总的来说，正如之前 yield 相关的代码展示的那样， yield 自动维护了相关的计数，手动维护全局变量。</p>
<p>在屏蔽底层 C语言 实现的细节下，我认为我们已经阐述清楚了 <strong>迭代器</strong> 这个概念，接下来我们继续讨论生成器。</p>
<p><img src="/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yield04.png" srcset="/img/loading.gif" lazyload alt="迭代器和生成器的区别-底层实现"></p>
<p>我们往底层实现来看，发现 迭代器 是很自然用了共享的 “清单” 变量，每次操作的时候，都需要维护这个 “清单” 变量，而生成器会自动的利用封存的 栈帧 来维持这个状态。</p>
<p><img src="/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yield05.png" srcset="/img/loading.gif" lazyload alt="生成器有栈帧"><br>这张图是刚开始使用，没有按照 文生图 提示词规则，而是直接使用自然语言描述得到的版本，宝贵的是能明显凸显出当生成器调用 .next() 的时候，会保存栈帧这个动作，因此这张图还是保留了下来。</p>
<h2 id="多进程、多线程、协程的区别"><a href="#多进程、多线程、协程的区别" class="headerlink" title="多进程、多线程、协程的区别"></a>多进程、多线程、协程的区别</h2><p>在我刚接触编程的时候，我就尝试用生活化的例子构建场景进行学习，现在终于可以轻松实现了。<br><img src="/2022/05/29/book/@2022_python_grammer_yield%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yield06.png" srcset="/img/loading.gif" lazyload alt="区别"></p>
<p>根本定义： </p>
<ol>
<li>进程是 资源分配 的最小单位；</li>
<li>线程是 CPU执行 的最小单位；</li>
<li>异步是具有 主动释放CPU执行 能力的执行程序（与上两者完全不是一个层面的概念）。</li>
</ol>
<p>进程:</p>
<ol>
<li>具有真正并行的能力（需要硬件 + 操作系统支持）；</li>
<li>正所谓 “并行计算”， 是真正能同时计算执行的；</li>
</ol>
<p>线程：</p>
<ol>
<li>“并发执行”，需要疯狂切上下文，实际上一个单位时间只能有一个线程在执行；</li>
<li>多线程本身并不能增加执行能力，除非当前有多个核心 + 语言的多线程支持多核心调用；</li>
<li>续：Python 3.14 前的 CPython解释器的 GIL 就是在 进程级 加上了 全局互斥锁， 因此一个同一时刻只能有一个线程能够被执行，就算有多个核心，也只有一把锁。多线程本身和多进程概念并不互斥。</li>
</ol>
<p>异步：</p>
<ol>
<li>需要代码本身有释放能力，也就是通过上文的生成器实现；</li>
<li>需要修改之前的代码，也就是出现经典的面试题： 如果异步代码中出现了同步的代码会怎么样-会占用整个进程导致其他的协程卡死；</li>
<li>await 高度借鉴了 yield from，通过 事件循环 监控区分后面接的 <strong>可等待对象（Awaitable）</strong> 是否完成</li>
<li>续：还没完成-就像上文中的递归，返回自己然后继续等待；完成-协程抛出 StopIteration 表示执行完成。</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本文从再次提笔到今天写后记，总共用时 10个 自然日，篇幅已经很长了，要是再展开协程，不知道要写到什么时候。<br>正如参考视频开篇提到的，只有当自己亲自总结的时候，才会发现原来对相关知识还是理解太浅薄了。</p>
<p>这些天查了很多资料，也高强度请教 AI， 还动手写了很多古老的代码，工作间隙也在想如何举例，润色。</p>
<p>没有打游戏，少量刷视频，没想到还是做了不少东西。</p>
<p>上周五是我人生中有一个最低谷（或者专业点，极低谷）的时候，想到放弃，想到逃避，压抑地话都说不出来。</p>
<p>好在开了个好头，希望我在之后的学习中能再接再厉，表现越来越好。</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Leetcode/" class="category-chain-item">Leetcode</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Python/" class="print-no-link">#Python</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>从二叉树遍历到yield，然后到协程、异步</div>
      <div>https://gou7ma7.github.io/2022/05/29/book/@2022_python_grammer_yield与二叉树遍历/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Roy Lee</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/30/devops/@2023_setup_kubernetes/" title="Kubernetes Setup in Local Physical Servers">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Kubernetes Setup in Local Physical Servers</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/29/leetcode/@2022_4_hard%E4%B8%AD%E4%BD%8D%E6%95%B0/" title="hard 4. Median of Two Sorted Arrays -- 第一道Hard，做了5年。">
                        <span class="hidden-mobile">hard 4. Median of Two Sorted Arrays -- 第一道Hard，做了5年。</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
<i class="iconfont icon-love"></i>
<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>

    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
